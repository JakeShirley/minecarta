<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>MineCarta - Map Viewer</title>
        <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
        <style>
            * {
                box-sizing: border-box;
            }
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                margin: 0;
                padding: 0;
                background: #1a1a2e;
                color: #eee;
                height: 100vh;
                display: flex;
                flex-direction: column;
            }
            header {
                background: #0f3460;
                padding: 10px 20px;
                display: flex;
                align-items: center;
                justify-content: space-between;
                border-bottom: 1px solid #1f4068;
            }
            h1 {
                margin: 0;
                font-size: 1.2rem;
                color: #6dd5ed;
            }
            .nav-btn {
                background: #16213e;
                color: #6dd5ed;
                text-decoration: none;
                padding: 8px 12px;
                border-radius: 4px;
                border: 1px solid #6dd5ed;
                font-size: 0.9rem;
            }
            .nav-btn:hover {
                background: #6dd5ed;
                color: #16213e;
            }

            main {
                flex: 1;
                display: flex;
                overflow: hidden;
            }

            .sidebar {
                width: 300px;
                background: #16213e;
                border-right: 1px solid #0f3460;
                padding: 15px;
                overflow-y: auto;
                display: flex;
                flex-direction: column;
                gap: 20px;
            }

            .map-container {
                flex: 1;
                position: relative;
            }

            #map {
                width: 100%;
                height: 100%;
                background: #000;
            }

            /* Disable image smoothing for crisp pixel-art tiles */
            #map img,
            .leaflet-tile,
            #tile-preview {
                image-rendering: pixelated;
                image-rendering: -moz-crisp-edges;
                image-rendering: crisp-edges;
            }

            /* Disable Leaflet's default tile fade animation to prevent flashing */
            .leaflet-tile-container {
                opacity: 1 !important;
            }
            .leaflet-tile {
                opacity: 1 !important;
                transition: none !important;
            }
            .leaflet-fade-anim .leaflet-tile {
                transition: none !important;
            }

            /* Coordinate display */
            .coord-display {
                position: absolute;
                bottom: 10px;
                left: 10px;
                background: rgba(15, 52, 96, 0.9);
                color: #6dd5ed;
                padding: 8px 12px;
                border-radius: 4px;
                font-family: 'Consolas', 'Monaco', monospace;
                font-size: 14px;
                z-index: 1000;
                border: 1px solid #1f4068;
                pointer-events: auto;
            }
            .coord-display .label {
                color: #888;
                font-size: 11px;
            }

            /* Minecraft World Clock */
            .world-clock {
                position: absolute;
                top: 10px;
                left: 50px;
                background: rgba(15, 52, 96, 0.9);
                color: #6dd5ed;
                padding: 6px 10px;
                border-radius: 4px;
                font-family: 'Consolas', 'Monaco', monospace;
                z-index: 1000;
                border: 1px solid #1f4068;
                display: flex;
                align-items: center;
                gap: 8px;
                user-select: none;
                height: 62px;
                box-sizing: border-box;
            }
            .clock-icon {
                width: 36px;
                height: 36px;
                border-radius: 50%;
                position: relative;
                overflow: hidden;
                border: 2px solid #1f4068;
                flex-shrink: 0;
            }
            .clock-day-half {
                position: absolute;
                width: 100%;
                height: 100%;
                transition: transform 0.5s ease;
            }
            .clock-sky {
                background: linear-gradient(to bottom, #87ceeb 0%, #e0f6ff 100%);
            }
            .clock-night {
                background: linear-gradient(to bottom, #0a1628 0%, #1a2a4a 100%);
            }
            .clock-sun {
                position: absolute;
                width: 12px;
                height: 12px;
                background: radial-gradient(circle, #ffe87c 0%, #ffd700 50%, #ffa500 100%);
                border-radius: 50%;
                box-shadow: 0 0 6px #ffd700;
                left: 50%;
                transform: translateX(-50%);
                transition: top 0.5s ease;
            }
            .clock-moon {
                position: absolute;
                width: 10px;
                height: 10px;
                background: radial-gradient(circle at 30% 30%, #f0f0f0 0%, #c0c0c0 50%, #a0a0a0 100%);
                border-radius: 50%;
                box-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
                left: 50%;
                transform: translateX(-50%);
                transition: top 0.5s ease;
            }
            .clock-info {
                display: flex;
                flex-direction: column;
                gap: 1px;
            }
            .clock-time {
                font-size: 14px;
                font-weight: bold;
                color: #6dd5ed;
                line-height: 1.1;
            }
            .clock-period {
                font-size: 10px;
                color: #888;
                text-transform: uppercase;
                line-height: 1.1;
            }
            .clock-day {
                font-size: 9px;
                color: #666;
                line-height: 1.1;
            }
            .clock-no-data {
                font-size: 12px;
                color: #666;
                font-style: italic;
            }

            /* Weather Widget */
            .world-weather {
                position: absolute;
                top: 10px;
                left: 200px;
                background: rgba(15, 52, 96, 0.9);
                color: #6dd5ed;
                padding: 6px 10px;
                border-radius: 4px;
                font-family: 'Consolas', 'Monaco', monospace;
                z-index: 1000;
                border: 1px solid #1f4068;
                display: flex;
                align-items: center;
                gap: 8px;
                user-select: none;
                height: 62px;
                box-sizing: border-box;
            }
            .weather-icon {
                width: 36px;
                height: 36px;
                border-radius: 4px;
                position: relative;
                overflow: hidden;
                border: 2px solid #1f4068;
                flex-shrink: 0;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 20px;
            }
            .weather-icon.clear {
                background: linear-gradient(to bottom, #87ceeb 0%, #b8e4f0 100%);
            }
            .weather-icon.rain {
                background: linear-gradient(to bottom, #5a6c7d 0%, #778899 100%);
            }
            .weather-icon.thunder {
                background: linear-gradient(to bottom, #2c3e50 0%, #4a5568 100%);
            }
            .weather-info {
                display: flex;
                flex-direction: column;
                gap: 1px;
            }
            .weather-type {
                font-size: 14px;
                font-weight: bold;
                color: #6dd5ed;
                line-height: 1.1;
            }
            .weather-desc {
                font-size: 10px;
                color: #888;
                line-height: 1.1;
            }
            .weather-no-data {
                font-size: 12px;
                color: #666;
                font-style: italic;
            }

            /* Grid line styling */
            .coord-grid-canvas {
                position: absolute;
                top: 0;
                left: 0;
                pointer-events: none;
                z-index: 500;
            }

            /* Grid labels */
            .grid-label {
                position: absolute;
                background: rgba(15, 52, 96, 0.9);
                color: #6dd5ed;
                padding: 2px 6px;
                border-radius: 3px;
                font-family: 'Consolas', 'Monaco', monospace;
                font-size: 11px;
                white-space: nowrap;
                border: 1px solid #1f4068;
                pointer-events: none;
                z-index: 501;
            }

            /* Player markers */
            .player-marker {
                display: flex;
                flex-direction: column;
                align-items: center;
                pointer-events: auto;
            }
            .player-head {
                width: 32px;
                height: 32px;
                border: 2px solid #6dd5ed;
                border-radius: 4px;
                background: #16213e;
                image-rendering: pixelated;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
            }
            .player-name {
                margin-top: 4px;
                background: rgba(15, 52, 96, 0.9);
                color: #6dd5ed;
                padding: 2px 6px;
                border-radius: 3px;
                font-family: 'Consolas', 'Monaco', monospace;
                font-size: 11px;
                white-space: nowrap;
                border: 1px solid #1f4068;
            }

            /* Chat bubble on player marker */
            .player-chat-bubble {
                position: absolute;
                bottom: 100%;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(255, 255, 255, 0.95);
                color: #1a1a2e;
                padding: 6px 10px;
                border-radius: 8px;
                font-size: 12px;
                max-width: 200px;
                word-wrap: break-word;
                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
                margin-bottom: 8px;
                opacity: 0;
                visibility: hidden;
                transition:
                    opacity 0.3s ease,
                    visibility 0.3s ease;
                z-index: 1000;
                pointer-events: none;
            }
            .player-chat-bubble.visible {
                opacity: 1;
                visibility: visible;
            }
            .player-chat-bubble::after {
                content: '';
                position: absolute;
                top: 100%;
                left: 50%;
                transform: translateX(-50%);
                border: 6px solid transparent;
                border-top-color: rgba(255, 255, 255, 0.95);
            }

            /* Player stats popup styling */
            .player-popup {
                min-width: 320px;
                background: #1a1a1a;
                padding: 12px;
                border-radius: 6px;
            }
            /* Remove default Leaflet popup styling */
            .player-popup-container .leaflet-popup-content-wrapper {
                background: #1a1a1a;
                border: none;
                box-shadow: 0 3px 14px rgba(0, 0, 0, 0.6);
                border-radius: 6px;
            }
            .player-popup-container .leaflet-popup-content {
                margin: 0;
            }
            .player-popup-container .leaflet-popup-tip {
                background: #1a1a1a;
            }
            .player-popup-header {
                display: flex;
                align-items: center;
                gap: 8px;
                margin-bottom: 8px;
                padding-bottom: 8px;
                border-bottom: 1px solid #333;
            }
            .player-popup-head {
                width: 32px;
                height: 32px;
                border-radius: 4px;
                image-rendering: pixelated;
            }
            .player-popup-name {
                font-weight: bold;
                font-size: 14px;
                color: #6dd5ed;
            }
            .player-popup-coords {
                font-size: 11px;
                color: #888;
                font-family: 'Consolas', 'Monaco', monospace;
            }
            .player-stats-row {
                display: flex;
                align-items: center;
                gap: 4px;
                margin: 6px 0;
                min-height: 27px;
            }
            .player-stats-label {
                width: 60px;
                font-size: 12px;
                color: #aaa;
            }
            .player-stats-icons {
                display: flex;
                gap: 0px;
                flex-wrap: wrap;
                width: 270px;
            }
            .stat-icon {
                width: 27px;
                height: 27px;
                image-rendering: pixelated;
                background-image: url('/icons.png');
                background-size: 768px 768px; /* 256x256 original * 3 */
                background-repeat: no-repeat;
                display: inline-block;
            }
            /* Heart icons - row 0 (y=0 in original, scaled 3x) */
            /* Icons are 9x9 original = 27x27 scaled. Positions are multiplied by 3 */
            .stat-icon.heart-empty {
                background-position: -48px 0;
            } /* x=16*3=48, y=0 */
            .stat-icon.heart-full {
                background-position: -156px 0;
            } /* x=52*3=156 */
            .stat-icon.heart-half {
                background-position: -183px 0;
            } /* x=61*3=183 */
            /* Armor icons - row 1 (y=9 in original = 27 scaled) */
            .stat-icon.armor-empty {
                background-position: -48px -27px;
            } /* x=16*3, y=9*3 */
            .stat-icon.armor-full {
                background-position: -102px -27px;
            } /* x=34*3=102 */
            .stat-icon.armor-half {
                background-position: -75px -27px;
            } /* x=25*3=75 */
            /* Hunger icons - row 3 (y=27 in original = 81 scaled) */
            .stat-icon.hunger-empty {
                background-position: -48px -81px;
            } /* x=16*3, y=27*3 */
            .stat-icon.hunger-full {
                background-position: -156px -81px;
            } /* x=52*3=156 */
            .stat-icon.hunger-half {
                background-position: -183px -81px;
            } /* x=61*3=183 */

            .stat-icon-half {
                width: 14px;
                height: 27px;
                overflow: hidden;
            }
            .stat-icon-half .stat-icon {
                width: 27px;
            }
            .player-stats-unavailable {
                font-size: 11px;
                color: #666;
                font-style: italic;
                margin-top: 8px;
            }

            /* Player list in sidebar */
            .player-list {
                max-height: 200px;
                overflow-y: auto;
            }
            .player-list-item {
                display: flex;
                align-items: center;
                gap: 8px;
                padding: 6px;
                background: #0f3460;
                border-radius: 4px;
                margin-bottom: 4px;
                cursor: pointer;
                transition: background 0.2s;
            }
            .player-list-item:hover {
                background: #1f4068;
            }
            .player-list-item img {
                width: 24px;
                height: 24px;
                border-radius: 3px;
                image-rendering: pixelated;
            }
            .player-list-item .player-info {
                flex: 1;
                font-size: 0.85rem;
            }
            .player-list-item .player-coords {
                font-size: 0.7rem;
                color: #888;
            }
            .player-count {
                font-size: 0.8rem;
                color: #888;
                margin-bottom: 8px;
            }

            .control-group {
                margin-bottom: 15px;
            }
            label {
                display: block;
                margin-bottom: 5px;
                color: #ccc;
                font-size: 0.9rem;
            }
            input,
            select {
                width: 100%;
                background: #0f3460;
                border: 1px solid #1f4068;
                color: white;
                padding: 6px;
                border-radius: 4px;
            }
            button {
                background: #e94560;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 4px;
                cursor: pointer;
                width: 100%;
                margin-top: 5px;
            }
            button:hover {
                background: #ff6b81;
            }

            /* Tile Preview */
            .tile-preview-container {
                /* Now handled by collapsible-section */
            }
            #tile-preview {
                width: 100%;
                aspect-ratio: 1;
                border: 1px solid #e94560;
                background-color: #000;
                background-image:
                    linear-gradient(45deg, #222 25%, transparent 25%),
                    linear-gradient(-45deg, #222 25%, transparent 25%),
                    linear-gradient(45deg, transparent 75%, #222 75%),
                    linear-gradient(-45deg, transparent 75%, #222 75%);
                background-size: 20px 20px;
                margin-bottom: 5px;
                display: block;
            }
            .tile-info {
                font-family: monospace;
                font-size: 0.8rem;
                color: #888;
                word-break: break-all;
            }

            /* Collapsible Section */
            .collapsible-section {
                border-top: 1px solid #0f3460;
                padding-top: 15px;
            }
            .collapsible-header {
                display: flex;
                align-items: center;
                justify-content: space-between;
                cursor: pointer;
                user-select: none;
                padding: 8px;
                margin: -8px -8px 0 -8px;
                border-radius: 4px;
                transition: background 0.2s;
            }
            .collapsible-header:hover {
                background: rgba(15, 52, 96, 0.5);
            }
            .collapsible-header label {
                margin: 0;
                cursor: pointer;
                display: flex;
                align-items: center;
                gap: 8px;
            }
            .collapsible-toggle {
                font-size: 0.8rem;
                color: #888;
                transition: transform 0.2s;
            }
            .collapsible-section.collapsed .collapsible-toggle {
                transform: rotate(-90deg);
            }
            .collapsible-content {
                overflow: hidden;
                transition:
                    max-height 0.3s ease,
                    opacity 0.2s ease,
                    margin-top 0.2s ease;
                max-height: 1000px;
                opacity: 1;
                margin-top: 8px;
            }
            .collapsible-section.collapsed .collapsible-content {
                max-height: 0;
                opacity: 0;
                margin-top: 0;
            }

            /* Chat Panel */
            .chat-panel {
                /* Styling handled by collapsible-section */
            }
            .chat-header {
                display: flex;
                align-items: center;
                justify-content: space-between;
                margin-bottom: 8px;
            }
            .chat-header label {
                margin: 0;
            }
            .chat-count {
                font-size: 0.75rem;
                color: #888;
            }
            .chat-messages {
                flex: 1;
                overflow-y: auto;
                background: #0f3460;
                border-radius: 4px;
                padding: 8px;
                min-height: 150px;
                max-height: 300px;
            }
            .chat-message {
                margin-bottom: 8px;
                padding-bottom: 8px;
                border-bottom: 1px solid #1f4068;
            }
            .chat-message:last-child {
                margin-bottom: 0;
                padding-bottom: 0;
                border-bottom: none;
            }
            .chat-message-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 2px;
            }
            .chat-player {
                font-weight: bold;
                color: #6dd5ed;
                font-size: 0.85rem;
            }
            .chat-time {
                font-size: 0.7rem;
                color: #666;
            }
            .chat-dimension {
                font-size: 0.65rem;
                color: #888;
                padding: 1px 4px;
                background: #16213e;
                border-radius: 2px;
            }
            .chat-text {
                font-size: 0.85rem;
                color: #ddd;
                word-break: break-word;
            }
            .chat-empty {
                text-align: center;
                color: #666;
                font-style: italic;
                font-size: 0.85rem;
                padding: 20px;
            }

            /* Dimension Toggle Buttons */
            .dimension-toggle {
                display: flex;
                gap: 4px;
                margin-bottom: 10px;
            }
            .dimension-btn {
                flex: 1;
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 4px;
                padding: 10px 8px;
                background: #0f3460;
                border: 2px solid transparent;
                border-radius: 6px;
                cursor: pointer;
                transition: all 0.2s ease;
                color: #888;
            }
            .dimension-btn:hover {
                background: #1f4068;
                color: #aaa;
            }
            .dimension-btn.active {
                border-color: var(--dimension-color, #6dd5ed);
                color: var(--dimension-color, #6dd5ed);
                background: rgba(15, 52, 96, 0.8);
            }
            .dimension-btn .dim-icon {
                font-size: 1.5rem;
            }
            .dimension-btn .dim-label {
                font-size: 0.7rem;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            .dimension-btn[data-dim='overworld'] {
                --dimension-color: #4ade80;
            }
            .dimension-btn[data-dim='nether'] {
                --dimension-color: #f87171;
            }
            .dimension-btn[data-dim='the_end'] {
                --dimension-color: #c084fc;
            }

            /* Map Type Toggle Buttons */
            .map-type-toggle {
                display: flex;
                gap: 4px;
                margin-bottom: 10px;
            }
            .map-type-btn {
                flex: 1;
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 4px;
                padding: 8px 6px;
                background: #0f3460;
                border: 2px solid transparent;
                border-radius: 6px;
                cursor: pointer;
                transition: all 0.2s ease;
                color: #888;
            }
            .map-type-btn:hover {
                background: #1f4068;
                color: #aaa;
            }
            .map-type-btn.active {
                border-color: #6dd5ed;
                color: #6dd5ed;
                background: rgba(15, 52, 96, 0.8);
            }
            .map-type-btn .type-icon {
                font-size: 1.2rem;
            }
            .map-type-btn .type-label {
                font-size: 0.65rem;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }

            /* Dimension-specific theming */
            body.dim-overworld {
                --accent-color: #4ade80;
                --accent-bg: rgba(74, 222, 128, 0.1);
            }
            body.dim-nether {
                --accent-color: #f87171;
                --accent-bg: rgba(248, 113, 113, 0.1);
            }
            body.dim-the_end {
                --accent-color: #c084fc;
                --accent-bg: rgba(192, 132, 252, 0.1);
            }

            body.dim-overworld .coord-display,
            body.dim-overworld .grid-label {
                border-color: rgba(74, 222, 128, 0.5);
                color: #4ade80;
            }
            body.dim-nether .coord-display,
            body.dim-nether .grid-label {
                border-color: rgba(248, 113, 113, 0.5);
                color: #f87171;
            }
            body.dim-the_end .coord-display,
            body.dim-the_end .grid-label {
                border-color: rgba(192, 132, 252, 0.5);
                color: #c084fc;
            }

            body.dim-overworld #ws-status.connected {
                background: rgba(74, 222, 128, 0.9) !important;
            }
            body.dim-nether #ws-status.connected {
                background: rgba(248, 113, 113, 0.9) !important;
            }
            body.dim-the_end #ws-status.connected {
                background: rgba(192, 132, 252, 0.9) !important;
            }

            /* Current dimension indicator in header */
            .current-dimension {
                display: flex;
                align-items: center;
                gap: 8px;
                padding: 6px 12px;
                background: var(--accent-bg, rgba(109, 213, 237, 0.1));
                border: 1px solid var(--accent-color, #6dd5ed);
                border-radius: 4px;
                font-size: 0.9rem;
            }
            .current-dimension .dim-icon {
                font-size: 1.2rem;
            }
            .current-dimension .dim-name {
                color: var(--accent-color, #6dd5ed);
                font-weight: 500;
            }

            /* Player dimension badge in list */
            .player-dimension-badge {
                font-size: 0.65rem;
                padding: 2px 4px;
                border-radius: 3px;
                margin-left: 4px;
            }
            .player-dimension-badge.overworld {
                background: rgba(74, 222, 128, 0.2);
                color: #4ade80;
            }
            .player-dimension-badge.nether {
                background: rgba(248, 113, 113, 0.2);
                color: #f87171;
            }
            .player-dimension-badge.the_end {
                background: rgba(192, 132, 252, 0.2);
                color: #c084fc;
            }

            /* All players toggle */
            .player-filter-toggle {
                display: flex;
                align-items: center;
                gap: 6px;
                margin-bottom: 8px;
                font-size: 0.8rem;
                color: #888;
            }
            .player-filter-toggle input {
                width: auto;
            }

            /* Spawn marker styles */
            .spawn-marker {
                display: flex;
                flex-direction: column;
                align-items: center;
                pointer-events: auto;
            }
            .spawn-icon {
                font-size: 24px;
                text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
                filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.5));
            }
            .spawn-label {
                margin-top: 2px;
                background: rgba(15, 52, 96, 0.9);
                color: #fff;
                padding: 2px 6px;
                border-radius: 3px;
                font-family: 'Consolas', 'Monaco', monospace;
                font-size: 10px;
                white-space: nowrap;
                border: 1px solid #1f4068;
            }
            .spawn-label.world-spawn {
                background: rgba(74, 222, 128, 0.9);
                border-color: #4ade80;
                color: #000;
            }
            .spawn-label.player-spawn {
                background: rgba(248, 113, 113, 0.9);
                border-color: #f87171;
                color: #000;
            }
        </style>
    </head>
    <body>
        <header>
            <h1><img src="logo.png" alt="MineCarta" style="height: 28px; vertical-align: middle" /></h1>
            <div style="display: flex; align-items: center; gap: 15px">
                <div class="current-dimension" id="current-dimension-display">
                    <span class="dim-icon">üåç</span>
                    <span class="dim-name">Overworld</span>
                </div>
                <div style="display: flex; gap: 10px">
                    <a href="api-tester.html" class="nav-btn">API Tester</a>
                    <a href="index.html" class="nav-btn">Home</a>
                </div>
            </div>
        </header>

        <main>
            <div class="sidebar">
                <div class="control-group">
                    <label>Dimension</label>
                    <div class="dimension-toggle" id="dimension-toggle">
                        <button
                            class="dimension-btn active"
                            data-dim="overworld"
                            onclick="selectDimension('overworld')"
                        >
                            <span class="dim-icon">üåç</span>
                            <span class="dim-label">Overworld</span>
                        </button>
                        <button class="dimension-btn" data-dim="nether" onclick="selectDimension('nether')">
                            <span class="dim-icon">üî•</span>
                            <span class="dim-label">Nether</span>
                        </button>
                        <button class="dimension-btn" data-dim="the_end" onclick="selectDimension('the_end')">
                            <span class="dim-icon">üåå</span>
                            <span class="dim-label">The End</span>
                        </button>
                    </div>
                    <!-- Hidden select for compatibility -->
                    <select id="tile-dim" style="display: none">
                        <option value="overworld">Overworld</option>
                        <option value="nether">Nether</option>
                        <option value="the_end">The End</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>Map Type</label>
                    <div class="map-type-toggle" id="map-type-toggle">
                        <button class="map-type-btn active" data-type="block" onclick="selectMapType('block')">
                            <span class="type-icon">üé®</span>
                            <span class="type-label">Block Colors</span>
                        </button>
                        <button class="map-type-btn" data-type="height" onclick="selectMapType('height')">
                            <span class="type-icon">‚õ∞Ô∏è</span>
                            <span class="type-label">Height Map</span>
                        </button>
                    </div>
                    <!-- Hidden select for compatibility -->
                    <select id="tile-map-type" style="display: none">
                        <option value="block">Block Colors</option>
                        <option value="height">Height Map</option>
                    </select>
                </div>

                <div class="control-group">
                    <button onclick="updateMapLayer()">Refresh Map</button>
                </div>

                <div class="control-group">
                    <label style="display: flex; align-items: center; gap: 8px">
                        <input type="checkbox" id="show-grid" style="width: auto" /> Show Coordinate Grid
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px">
                        <input type="checkbox" id="show-players" checked style="width: auto" /> Show Players
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px">
                        <input type="checkbox" id="show-spawns" style="width: auto" /> Show Spawn Points
                    </label>
                </div>

                <div class="control-group">
                    <label>Online Players</label>
                    <div class="player-filter-toggle">
                        <input type="checkbox" id="show-all-dimensions" />
                        <label for="show-all-dimensions" style="margin: 0; font-size: 0.8rem"
                            >Show players from all dimensions</label
                        >
                    </div>
                    <div class="player-count" id="player-count">0 players</div>
                    <div class="player-list" id="player-list"></div>
                </div>

                <div class="chat-panel collapsible-section" id="chat-section">
                    <div class="collapsible-header" onclick="toggleSection('chat-section')">
                        <label>üí¨ Chat Stream</label>
                        <div style="display: flex; align-items: center; gap: 8px">
                            <span class="chat-count" id="chat-count">0 messages</span>
                            <span class="collapsible-toggle">‚ñº</span>
                        </div>
                    </div>
                    <div class="collapsible-content">
                        <div class="chat-messages" id="chat-messages">
                            <div class="chat-empty">No messages yet...</div>
                        </div>
                    </div>
                </div>

                <div class="tile-preview-container collapsible-section" id="tile-inspector-section">
                    <div class="collapsible-header" onclick="toggleSection('tile-inspector-section')">
                        <label>üîç Tile Inspector</label>
                        <span class="collapsible-toggle">‚ñº</span>
                    </div>
                    <div class="collapsible-content">
                        <div style="display: flex; gap: 5px; margin-bottom: 5px">
                            <div style="flex: 1">
                                <label style="font-size: 0.8em">Zoom</label
                                ><input type="number" id="preview-z" value="2" min="0" max="7" />
                            </div>
                            <div style="flex: 1">
                                <label style="font-size: 0.8em">X</label
                                ><input type="number" id="preview-x" value="0" />
                            </div>
                            <div style="flex: 1">
                                <label style="font-size: 0.8em">Z</label
                                ><input type="number" id="preview-y" value="0" />
                            </div>
                        </div>
                        <button onclick="loadTile()">Preview Tile</button>
                        <img id="tile-preview" alt="Tile Preview" />
                        <div class="tile-info" id="tile-url"></div>
                    </div>
                </div>

                <div style="margin-top: auto; font-size: 0.8rem; color: #666">
                    <p>Pan: Drag</p>
                    <p>Zoom: Scroll</p>
                </div>
            </div>

            <div class="map-container">
                <div id="map"></div>
                <div class="world-clock" id="world-clock">
                    <div class="clock-icon" id="clock-icon">
                        <div class="clock-day-half clock-sky" id="clock-sky"></div>
                        <div class="clock-day-half clock-night" id="clock-night"></div>
                        <div class="clock-sun" id="clock-sun"></div>
                        <div class="clock-moon" id="clock-moon"></div>
                    </div>
                    <div class="clock-info">
                        <div class="clock-time" id="clock-time">--:--</div>
                        <div class="clock-period" id="clock-period">---</div>
                        <div class="clock-day" id="clock-day">Day --</div>
                    </div>
                </div>
                <div class="world-weather" id="world-weather">
                    <div class="weather-icon clear" id="weather-icon">‚òÄÔ∏è</div>
                    <div class="weather-info">
                        <div class="weather-type" id="weather-type">---</div>
                        <div class="weather-desc" id="weather-desc">Waiting...</div>
                    </div>
                </div>
                <div
                    class="coord-display"
                    id="coord-display"
                    style="cursor: pointer"
                    title="Click to toggle between block and chunk coordinates"
                >
                    <div class="label" id="coord-label">Block Coordinates</div>
                    <div id="coord-text">X: 0, Z: 0</div>
                    <div id="zoom-text" style="font-size: 11px; color: #888; margin-top: 4px">Zoom: 3</div>
                </div>
            </div>
        </main>

        <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
        <script>
            const API_BASE = '/api/v1';

            // Dimension configuration
            const DIMENSION_CONFIG = {
                overworld: { icon: 'üåç', name: 'Overworld', color: '#4ade80', bgColor: '#000000' },
                nether: { icon: 'üî•', name: 'Nether', color: '#f87171', bgColor: '#330000' },
                the_end: { icon: 'üåå', name: 'The End', color: '#c084fc', bgColor: '#1c0333' },
            };

            // Current dimension (load from localStorage or default to overworld)
            let currentDimension = localStorage.getItem('map-dimension') || 'overworld';

            // Current map type (load from localStorage or default to block)
            let currentMapType = localStorage.getItem('map-type') || 'block';

            // Player state (declared early so selectDimension can reference them)
            let playerMarkers = new Map(); // Map of player name -> { marker, currentPos, targetPos, startPos, lerpStartTime }
            let playersVisible = true;
            let currentPlayers = []; // Store current player data
            let playerAnimationFrame = null; // Animation frame ID for player lerping
            let chatBubbleTimeouts = new Map(); // Map of player name -> timeout ID for hiding chat bubbles

            // Spawn state
            let worldSpawnMarker = null; // Single marker for world spawn
            let playerSpawnMarkers = new Map(); // Map of player name -> marker
            let currentWorldSpawn = null; // Current world spawn data
            let currentPlayerSpawns = []; // Current player spawns data
            let spawnsVisible = false;

            // World clock state
            let worldTimeData = null; // { timeOfDay, absoluteTime, day }
            let worldTimeSyncTimestamp = null; // When we received the last sync (real-world ms)
            let clockUpdateInterval = null; // Interval for updating the clock display

            /**
             * Minecraft time constants
             * - 1 day = 24000 ticks
             * - Time of day 0 = 6:00 AM (sunrise)
             * - 1 tick = 1/20 real-world second (50ms)
             */
            const MC_TICKS_PER_DAY = 24000;
            const MC_TICKS_PER_SECOND = 20;
            const REAL_MS_PER_MC_TICK = 50; // 1000ms / 20 ticks

            /**
             * Convert Minecraft time of day (0-23999) to 12-hour format time string
             */
            function mcTimeToString(timeOfDay) {
                // Minecraft time 0 = 6:00 AM
                // So we offset by 6 hours (6000 ticks)
                const adjustedTime = (timeOfDay + 6000) % MC_TICKS_PER_DAY;

                // Convert to hours and minutes
                // 24000 ticks = 24 hours, so 1000 ticks = 1 hour
                const totalMinutes = Math.floor((adjustedTime / MC_TICKS_PER_DAY) * 24 * 60);
                let hours = Math.floor(totalMinutes / 60);
                const minutes = totalMinutes % 60;

                // Convert to 12-hour format
                const period = hours >= 12 ? 'PM' : 'AM';
                hours = hours % 12;
                if (hours === 0) hours = 12;

                return {
                    time: `${hours}:${minutes.toString().padStart(2, '0')}`,
                    period: period,
                };
            }

            /**
             * Get the time period name based on Minecraft time of day
             */
            function getTimePeriod(timeOfDay) {
                // Dawn: 23000-24000, 0-1000 (5:00 AM - 7:00 AM)
                // Day: 1000-12000 (7:00 AM - 6:00 PM)
                // Dusk: 12000-13000 (6:00 PM - 7:00 PM)
                // Night: 13000-23000 (7:00 PM - 5:00 AM)

                if (timeOfDay >= 23000 || timeOfDay < 1000) {
                    return { name: 'Dawn', icon: 'üåÖ' };
                } else if (timeOfDay >= 1000 && timeOfDay < 6000) {
                    return { name: 'Morning', icon: '‚òÄÔ∏è' };
                } else if (timeOfDay >= 6000 && timeOfDay < 12000) {
                    return { name: 'Day', icon: 'üåû' };
                } else if (timeOfDay >= 12000 && timeOfDay < 13000) {
                    return { name: 'Dusk', icon: 'üåá' };
                } else {
                    return { name: 'Night', icon: 'üåô' };
                }
            }

            /**
             * Check if it's currently "night" in Minecraft (mobs spawn, sleeping allowed)
             */
            function isNight(timeOfDay) {
                return timeOfDay >= 12542 && timeOfDay < 23460;
            }

            /**
             * Predict current Minecraft time based on last sync and elapsed real time
             */
            function predictCurrentTime() {
                if (!worldTimeData || !worldTimeSyncTimestamp) {
                    return null;
                }

                const elapsed = Date.now() - worldTimeSyncTimestamp;
                const ticksElapsed = Math.floor(elapsed / REAL_MS_PER_MC_TICK);

                const predictedTimeOfDay = (worldTimeData.timeOfDay + ticksElapsed) % MC_TICKS_PER_DAY;
                const predictedAbsoluteTime = worldTimeData.absoluteTime + ticksElapsed;
                const predictedDay =
                    worldTimeData.day + Math.floor((worldTimeData.timeOfDay + ticksElapsed) / MC_TICKS_PER_DAY);

                return {
                    timeOfDay: predictedTimeOfDay,
                    absoluteTime: predictedAbsoluteTime,
                    day: predictedDay,
                };
            }

            /**
             * Update the clock display
             */
            function updateClockDisplay() {
                const time = predictCurrentTime();

                const clockTime = document.getElementById('clock-time');
                const clockPeriod = document.getElementById('clock-period');
                const clockDay = document.getElementById('clock-day');
                const clockSun = document.getElementById('clock-sun');
                const clockMoon = document.getElementById('clock-moon');
                const clockSky = document.getElementById('clock-sky');
                const clockNight = document.getElementById('clock-night');

                if (!time) {
                    clockTime.textContent = '--:--';
                    clockPeriod.textContent = '‚è≥ Waiting';
                    clockDay.textContent = 'Connect Minecraft';
                    clockSun.style.display = 'none';
                    clockMoon.style.display = 'none';
                    // Show a dim day sky as placeholder
                    clockSky.style.opacity = '0.3';
                    clockNight.style.opacity = '0';
                    return;
                }

                const { time: timeStr, period } = mcTimeToString(time.timeOfDay);
                const timePeriod = getTimePeriod(time.timeOfDay);
                const night = isNight(time.timeOfDay);

                clockTime.textContent = timeStr;
                clockPeriod.textContent = `${timePeriod.icon} ${timePeriod.name}`;
                clockDay.textContent = `Day ${time.day + 1}`; // Display as 1-based

                // Update sun/moon positions based on time
                // Sun visible during day (0-12000), Moon visible during night (12000-24000)
                if (time.timeOfDay < 12000) {
                    // Daytime - show sun
                    clockSun.style.display = 'block';
                    clockMoon.style.display = 'none';

                    // Sun arc: rises from bottom (0), peaks at top (6000), sets to bottom (12000)
                    // Map 0-12000 to 100% -> 5% -> 100% (top position)
                    const progress = time.timeOfDay / 12000; // 0 to 1
                    const sunY = 5 + 90 * Math.abs(Math.sin(progress * Math.PI));
                    clockSun.style.top = `${100 - sunY}%`;

                    // Show sky, hide night
                    clockSky.style.opacity = '1';
                    clockNight.style.opacity = '0';
                } else {
                    // Nighttime - show moon
                    clockSun.style.display = 'none';
                    clockMoon.style.display = 'block';

                    // Moon arc: rises from bottom (12000), peaks at top (18000), sets to bottom (24000)
                    const nightProgress = (time.timeOfDay - 12000) / 12000; // 0 to 1
                    const moonY = 5 + 90 * Math.abs(Math.sin(nightProgress * Math.PI));
                    clockMoon.style.top = `${100 - moonY}%`;

                    // Show night, hide sky
                    clockSky.style.opacity = '0';
                    clockNight.style.opacity = '1';
                }
            }

            /**
             * Handle world time sync from server
             */
            function handleTimeSync(time) {
                worldTimeData = time;
                worldTimeSyncTimestamp = Date.now();
                updateClockDisplay();

                // Start the clock update interval if not running
                if (!clockUpdateInterval) {
                    // Update every second for smooth display
                    clockUpdateInterval = setInterval(updateClockDisplay, 1000);
                }
            }

            // ==========================================
            // Weather Display
            // ==========================================

            /**
             * Current weather state
             */
            let worldWeatherData = null;

            /**
             * Weather configuration for display
             */
            const WEATHER_CONFIG = {
                Clear: {
                    icon: '‚òÄÔ∏è',
                    name: 'Clear',
                    desc: 'Clear skies',
                    class: 'clear',
                },
                Rain: {
                    icon: 'üåßÔ∏è',
                    name: 'Rain',
                    desc: 'Raining',
                    class: 'rain',
                },
                Thunder: {
                    icon: '‚õàÔ∏è',
                    name: 'Thunder',
                    desc: 'Thunderstorm',
                    class: 'thunder',
                },
            };

            /**
             * Update the weather display
             */
            function updateWeatherDisplay() {
                const weatherIcon = document.getElementById('weather-icon');
                const weatherType = document.getElementById('weather-type');
                const weatherDesc = document.getElementById('weather-desc');

                if (!worldWeatherData) {
                    weatherIcon.textContent = '‚ùì';
                    weatherIcon.className = 'weather-icon';
                    weatherType.textContent = '---';
                    weatherDesc.textContent = 'Connect Minecraft';
                    return;
                }

                const config = WEATHER_CONFIG[worldWeatherData.weather] || WEATHER_CONFIG.Clear;

                weatherIcon.textContent = config.icon;
                weatherIcon.className = `weather-icon ${config.class}`;
                weatherType.textContent = config.name;
                weatherDesc.textContent = config.desc;
            }

            /**
             * Handle world weather sync from server
             */
            function handleWeatherSync(weather) {
                worldWeatherData = weather;
                updateWeatherDisplay();
            }

            /**
             * Toggle collapsible section
             */
            function toggleSection(sectionId) {
                const section = document.getElementById(sectionId);
                if (section) {
                    section.classList.toggle('collapsed');
                    // Save state to localStorage
                    const isCollapsed = section.classList.contains('collapsed');
                    localStorage.setItem(`section-${sectionId}`, isCollapsed ? 'collapsed' : 'expanded');
                }
            }

            /**
             * Restore collapsible section states from localStorage
             * Default: chat expanded, tile inspector collapsed
             */
            function restoreCollapsibleStates() {
                const defaults = {
                    'chat-section': 'expanded',
                    'tile-inspector-section': 'collapsed',
                };

                Object.entries(defaults).forEach(([sectionId, defaultState]) => {
                    const state = localStorage.getItem(`section-${sectionId}`) || defaultState;
                    const section = document.getElementById(sectionId);
                    if (section) {
                        if (state === 'collapsed') {
                            section.classList.add('collapsed');
                        } else {
                            section.classList.remove('collapsed');
                        }
                    }
                });
            }

            /**
             * Select and apply a dimension
             */
            function selectDimension(dimension) {
                currentDimension = dimension;
                localStorage.setItem('map-dimension', dimension);

                // Update hidden select for compatibility
                document.getElementById('tile-dim').value = dimension;

                // Update toggle button states
                document.querySelectorAll('.dimension-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.dim === dimension);
                });

                // Update body theme class
                document.body.classList.remove('dim-overworld', 'dim-nether', 'dim-the_end');
                document.body.classList.add(`dim-${dimension}`);

                // Update header display
                const config = DIMENSION_CONFIG[dimension];
                const display = document.getElementById('current-dimension-display');
                display.querySelector('.dim-icon').textContent = config.icon;
                display.querySelector('.dim-name').textContent = config.name;

                // Update map background color based on dimension
                document.getElementById('map').style.backgroundColor = config.bgColor;

                // Update map and players
                updateMapLayer();
                loadTile();

                // Refresh player display
                for (const data of playerMarkers.values()) {
                    map.removeLayer(data.marker);
                }
                playerMarkers.clear();
                // Only update if functions are defined (during initial load they may not be yet)
                if (typeof updatePlayerMarkers === 'function') {
                    updatePlayerMarkers(currentPlayers);
                    updatePlayerList(currentPlayers);
                }
            }

            /**
             * Select and apply a map type
             */
            function selectMapType(mapType) {
                currentMapType = mapType;
                localStorage.setItem('map-type', mapType);

                // Update hidden select for compatibility
                document.getElementById('tile-map-type').value = mapType;

                // Update toggle button states
                document.querySelectorAll('.map-type-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.type === mapType);
                });

                // Update map layer
                updateMapLayer();
                loadTile();
            }

            /**
             * Initialize dimension on page load
             */
            function initializeDimension() {
                selectDimension(currentDimension);
                selectMapType(currentMapType);
                restoreCollapsibleStates();
            }

            // Server zoom levels: 0 (16 blocks/tile, highest detail) to 7 (2048 blocks/tile)
            // Leaflet: higher zoom = more zoomed in (bigger tiles visually)
            const MAX_ZOOM = 7;

            // Blocks per tile at each server zoom level (must match server constants!)
            // z0: 16 blocks per tile (1 chunk)
            // z4: 256 blocks per tile (1 pixel = 1 block)
            // z6: 1024 blocks per tile
            // z7: 2048 blocks per tile
            const BLOCKS_PER_TILE = {
                0: 16,
                1: 32,
                2: 64,
                3: 128,
                4: 256,
                5: 512,
                6: 1024,
                7: 2048,
            };

            // Map Init
            const map = L.map('map', {
                crs: L.CRS.Simple,
                minZoom: 0,
                maxZoom: MAX_ZOOM,
                center: [0, 0],
                zoom: 3,
                zoomControl: true,
                zoomSnap: 1,
                zoomDelta: 1,
            });

            let tileLayer;

            /**
             * Convert Leaflet coordinates to Minecraft world coordinates
             *
             * With the inverted zoom mapping:
             * - Leaflet zoom 7 = Server zoom 0 (16 blocks/tile, highest detail)
             * - Leaflet zoom 0 = Server zoom 7 (2048 blocks/tile, lowest detail)
             *
             * In CRS.Simple, at any zoom level z, the latlng to pixel scale is 2^z.
             * A tile is always 256x256 pixels.
             * At Leaflet zoom z, a tile covers (256 / 2^z) latlng units.
             * At Leaflet zoom z, server zoom = MAX_ZOOM - z, so blocks per tile = BLOCKS_PER_TILE[serverZoom].
             *
             * We use Leaflet zoom 0 as our reference for coordinate mapping:
             * - At Leaflet zoom 0: 1 tile = 256 latlng units = 2048 blocks (server zoom 7)
             * - So: 1 latlng unit = 2048/256 = 8 blocks
             */
            const BLOCKS_PER_LATLNG_UNIT = BLOCKS_PER_TILE[MAX_ZOOM] / 256; // 2048/256 = 8

            function leafletToMinecraft(latlng) {
                const mcX = Math.floor(latlng.lng * BLOCKS_PER_LATLNG_UNIT);
                const mcZ = Math.floor(-latlng.lat * BLOCKS_PER_LATLNG_UNIT);

                return { x: mcX, z: mcZ };
            }

            /**
             * Convert Minecraft coordinates to Leaflet coordinates
             * This is zoom-independent.
             */
            function minecraftToLeaflet(mcX, mcZ) {
                const lat = -(mcZ / BLOCKS_PER_LATLNG_UNIT);
                const lng = mcX / BLOCKS_PER_LATLNG_UNIT;

                return L.latLng(lat, lng);
            }

            /**
             * Coordinate display mode: 'block' or 'chunk'
             */
            let coordDisplayMode = localStorage.getItem('coord-display-mode') || 'block';
            let lastMouseCoords = { x: 0, z: 0 };

            /**
             * Update coordinate display with mouse position
             */
            function updateCoordDisplay(e) {
                const coords = leafletToMinecraft(e.latlng);
                lastMouseCoords = coords;
                renderCoordDisplay();
            }

            /**
             * Render the coordinate display based on current mode
             */
            function renderCoordDisplay() {
                const coords = lastMouseCoords;
                if (coordDisplayMode === 'chunk') {
                    const chunkX = Math.floor(coords.x / 16);
                    const chunkZ = Math.floor(coords.z / 16);
                    document.getElementById('coord-text').textContent = `X: ${chunkX}, Z: ${chunkZ}`;
                    document.getElementById('coord-label').textContent = 'Chunk Coordinates';
                } else {
                    document.getElementById('coord-text').textContent = `X: ${coords.x}, Z: ${coords.z}`;
                    document.getElementById('coord-label').textContent = 'Block Coordinates';
                }
            }

            /**
             * Toggle between block and chunk coordinate display modes
             */
            function toggleCoordDisplayMode() {
                coordDisplayMode = coordDisplayMode === 'block' ? 'chunk' : 'block';
                localStorage.setItem('coord-display-mode', coordDisplayMode);
                renderCoordDisplay();
            }

            // Add click handler for coordinate display toggle
            document.getElementById('coord-display').addEventListener('click', toggleCoordDisplayMode);

            /**
             * Update zoom display
             */
            function updateZoomDisplay() {
                const leafletZoom = map.getZoom();
                const serverZoom = MAX_ZOOM - leafletZoom;
                const blocksPerTile = BLOCKS_PER_TILE[serverZoom];
                document.getElementById('zoom-text').textContent =
                    `Zoom: ${leafletZoom} (${blocksPerTile} blocks/tile)`;
            }

            map.on('mousemove', updateCoordDisplay);
            map.on('zoomend', updateZoomDisplay);

            /**
             * Canvas-based coordinate grid overlay
             * Draws clean grid lines at regular Minecraft coordinate intervals
             */
            class CoordGridOverlay {
                constructor(map) {
                    this.map = map;
                    this.canvas = null;
                    this.ctx = null;
                    this.labelContainer = null;
                    this.visible = true;
                    this._onMove = this._onMove.bind(this);
                    this._init();
                }

                _init() {
                    // Create canvas for grid lines
                    this.canvas = document.createElement('canvas');
                    this.canvas.className = 'coord-grid-canvas';
                    this.map.getContainer().appendChild(this.canvas);
                    this.ctx = this.canvas.getContext('2d');

                    // Create container for labels
                    this.labelContainer = document.createElement('div');
                    this.labelContainer.style.cssText =
                        'position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:501;overflow:hidden;';
                    this.map.getContainer().appendChild(this.labelContainer);

                    // Bind events
                    this.map.on('move zoom resize zoomend moveend', this._onMove);

                    // Initial render
                    this._resize();
                    this._render();
                }

                _resize() {
                    const container = this.map.getContainer();
                    const rect = container.getBoundingClientRect();
                    this.canvas.width = rect.width;
                    this.canvas.height = rect.height;
                    this.canvas.style.width = rect.width + 'px';
                    this.canvas.style.height = rect.height + 'px';
                }

                _onMove() {
                    this._resize();
                    this._render();
                }

                /**
                 * Choose grid spacing based on zoom level
                 * We want roughly 3-6 grid lines visible on screen
                 */
                _getGridSpacing() {
                    const leafletZoom = this.map.getZoom();
                    // Get the server zoom and blocks per tile at current zoom
                    const serverZoom = MAX_ZOOM - leafletZoom;
                    const blocksPerTile = BLOCKS_PER_TILE[serverZoom];
                    // At any zoom, a tile is 256 pixels
                    const blocksPerPixel = blocksPerTile / 256;

                    // Approximate pixels per 1000 blocks
                    const pixelsPer1000Blocks = 1000 / blocksPerPixel;

                    // Choose spacing so we get reasonable number of lines
                    // Prefer nice round numbers in Minecraft coords
                    if (pixelsPer1000Blocks > 800) return 256; // Very zoomed in
                    if (pixelsPer1000Blocks > 400) return 512;
                    if (pixelsPer1000Blocks > 200) return 1024;
                    if (pixelsPer1000Blocks > 100) return 2048;
                    if (pixelsPer1000Blocks > 50) return 4096;
                    if (pixelsPer1000Blocks > 25) return 8192;
                    return 16384; // Very zoomed out
                }

                _render() {
                    if (!this.visible) {
                        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                        this.labelContainer.innerHTML = '';
                        return;
                    }

                    const ctx = this.ctx;
                    const width = this.canvas.width;
                    const height = this.canvas.height;

                    ctx.clearRect(0, 0, width, height);
                    this.labelContainer.innerHTML = '';

                    const spacing = this._getGridSpacing();

                    // Get bounds in Minecraft coordinates
                    const bounds = this.map.getBounds();
                    const topLeft = leafletToMinecraft(bounds.getNorthWest());
                    const bottomRight = leafletToMinecraft(bounds.getSouthEast());

                    // Calculate first grid line positions (round to spacing)
                    const startX = Math.floor(topLeft.x / spacing) * spacing;
                    const endX = Math.ceil(bottomRight.x / spacing) * spacing;
                    const startZ = Math.floor(bottomRight.z / spacing) * spacing;
                    const endZ = Math.ceil(topLeft.z / spacing) * spacing;

                    // Draw settings
                    ctx.strokeStyle = 'rgba(109, 213, 237, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([]);

                    const labels = [];

                    // Draw vertical lines (constant X)
                    for (let mcX = startX; mcX <= endX; mcX += spacing) {
                        const topPoint = minecraftToLeaflet(mcX, topLeft.z);
                        const bottomPoint = minecraftToLeaflet(mcX, bottomRight.z);

                        const topScreen = this.map.latLngToContainerPoint(topPoint);
                        const bottomScreen = this.map.latLngToContainerPoint(bottomPoint);

                        ctx.beginPath();
                        ctx.moveTo(Math.round(topScreen.x) + 0.5, 0);
                        ctx.lineTo(Math.round(bottomScreen.x) + 0.5, height);
                        ctx.stroke();

                        // Add X label at top
                        if (topScreen.x > 30 && topScreen.x < width - 30) {
                            labels.push({ x: topScreen.x, y: 10, text: `X: ${mcX}`, type: 'x' });
                        }
                    }

                    // Draw horizontal lines (constant Z)
                    for (let mcZ = startZ; mcZ <= endZ; mcZ += spacing) {
                        const leftPoint = minecraftToLeaflet(topLeft.x, mcZ);
                        const rightPoint = minecraftToLeaflet(bottomRight.x, mcZ);

                        const leftScreen = this.map.latLngToContainerPoint(leftPoint);
                        const rightScreen = this.map.latLngToContainerPoint(rightPoint);

                        ctx.beginPath();
                        ctx.moveTo(0, Math.round(leftScreen.y) + 0.5);
                        ctx.lineTo(width, Math.round(rightScreen.y) + 0.5);
                        ctx.stroke();

                        // Add Z label at left
                        if (leftScreen.y > 20 && leftScreen.y < height - 20) {
                            labels.push({ x: 10, y: leftScreen.y, text: `Z: ${mcZ}`, type: 'z' });
                        }
                    }

                    // Render labels
                    labels.forEach(label => {
                        const el = document.createElement('div');
                        el.className = 'grid-label';
                        el.textContent = label.text;
                        el.style.left = label.x + 'px';
                        el.style.top = label.y + 'px';
                        if (label.type === 'x') {
                            el.style.transform = 'translateX(-50%)';
                        }
                        this.labelContainer.appendChild(el);
                    });
                }

                setVisible(visible) {
                    this.visible = visible;
                    this.canvas.style.display = visible ? 'block' : 'none';
                    this.labelContainer.style.display = visible ? 'block' : 'none';
                    if (visible) this._render();
                }

                remove() {
                    this.map.off('move zoom resize zoomend moveend', this._onMove);
                    this.canvas.remove();
                    this.labelContainer.remove();
                }
            }

            let gridOverlay = null;

            document.getElementById('show-grid').addEventListener('change', function () {
                if (gridOverlay) {
                    gridOverlay.setVisible(this.checked);
                }
            });

            function updateMapLayer() {
                if (tileLayer) {
                    map.removeLayer(tileLayer);
                }

                const dim = document.getElementById('tile-dim').value;
                const mapType = document.getElementById('tile-map-type').value;

                // Custom TileLayer with refresh support that doesn't cause flicker
                // Based on: https://github.com/Leaflet/Leaflet/issues/6659
                L.TileLayer.Minecraft = L.TileLayer.extend({
                    options: {
                        minZoom: 0,
                        maxZoom: MAX_ZOOM,
                        // Allow native tile fetching at all zoom levels
                        minNativeZoom: 0,
                        maxNativeZoom: MAX_ZOOM,
                        tileSize: 256,
                        noWrap: true,
                    },

                    initialize: function (options) {
                        L.TileLayer.prototype.initialize.call(this, '', options);
                        this._currentDim = dim;
                        this._currentMapType = mapType;

                        // Store reference to original _tileOnLoad
                        const originalTileOnLoad = this._tileOnLoad;

                        // Override _tileOnLoad to skip animation for refreshed tiles
                        this._tileOnLoad = function (done, tile) {
                            if (tile.hasAttribute('data-dynamic-refresh')) {
                                // This is a refreshed tile - skip animation, just mark as loaded
                                tile.removeAttribute('data-dynamic-refresh');
                                L.DomUtil.addClass(tile, 'leaflet-tile-loaded');
                                done(null, tile);
                            } else {
                                // Normal tile load - use original behavior
                                originalTileOnLoad.call(this, done, tile);
                            }
                        };
                    },

                    getTileUrl: function (coords) {
                        // Server zoom levels are inverted from Leaflet:
                        // Leaflet zoom 7 (most zoomed in) = Server zoom 0 (highest detail, 16 blocks/tile)
                        // Leaflet zoom 0 (most zoomed out) = Server zoom 7 (lowest detail, 2048 blocks/tile)
                        const serverZoom = MAX_ZOOM - coords.z;
                        return `${API_BASE}/tiles/${this._currentDim}/${this._currentMapType}/${serverZoom}/${coords.x}/${coords.y}.png`;
                    },

                    getAttribution: function () {
                        return 'MineCarta';
                    },

                    // Refresh specific tiles without flicker
                    refresh: function (tileCoords) {
                        const layer = this;
                        const tilesToRefresh = new Set(tileCoords.map(t => `${t.x}:${t.z}`));

                        // Temporarily disable map fade animation
                        const wasFadeAnimated = map._fadeAnimated;
                        map._fadeAnimated = false;

                        // Loop through internal _tiles object
                        for (const key in this._tiles) {
                            const tile = this._tiles[key];
                            if (!tile || !tile.el) continue;

                            const coords = tile.coords;
                            const tileKey = `${coords.x}:${coords.y}`;

                            if (tilesToRefresh.has(tileKey)) {
                                const newUrl = this.getTileUrl(coords) + '?v=' + Date.now();

                                // Preload the new image
                                const preloadImg = new Image();
                                preloadImg.onload = (function (tileEl, url) {
                                    return function () {
                                        // Mark tile for dynamic refresh (skip animation)
                                        tileEl.setAttribute('data-dynamic-refresh', 'true');
                                        // Swap the src - this will trigger _tileOnLoad
                                        tileEl.src = url;
                                    };
                                })(tile.el, newUrl);

                                preloadImg.src = newUrl;
                            }
                        }

                        // Re-enable fade animation after a short delay
                        setTimeout(function () {
                            map._fadeAnimated = wasFadeAnimated;
                        }, 1000);
                    },

                    // Ensure 404s don't look broken - use dimension-specific color
                    // Black for overworld/the_end, dark red for nether
                    errorTileUrl:
                        DIMENSION_CONFIG[dim].bgColor === '#330000'
                            ? 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mMw0DD4HwADgAF/el0powAAAABJRU5ErkJggg==' // Dark red (#330000)
                            : 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNgYGD4HwABAgEApxoE6QAAAABJRU5ErkJggg==', // Black (#000000)
                });

                tileLayer = new L.TileLayer.Minecraft().addTo(map);
            }

            function loadTile() {
                const dim = document.getElementById('tile-dim').value;
                const mapType = document.getElementById('tile-map-type').value;
                const z = document.getElementById('preview-z').value;
                const x = document.getElementById('preview-x').value;
                const y = document.getElementById('preview-y').value;

                const url = `${API_BASE}/tiles/${dim}/${mapType}/${z}/${x}/${y}.png?t=${Date.now()}`;
                const img = document.getElementById('tile-preview');
                img.src = url;

                const displayUrl = `${API_BASE}/tiles/${dim}/${mapType}/${z}/${x}/${y}.png`;
                document.getElementById('tile-url').innerText = displayUrl;

                img.onerror = () => {
                    document.getElementById('tile-url').innerText = displayUrl + ' (Not Found)';
                };
            }

            // Event Listeners
            document.getElementById('tile-dim').addEventListener('change', () => {
                updateMapLayer();
                loadTile();
            });

            // Initial Load
            initializeDimension(); // This calls updateMapLayer() and loadTile()
            gridOverlay = new CoordGridOverlay(map); // Create grid overlay
            gridOverlay.setVisible(false);
            updateZoomDisplay(); // Initial zoom display

            // ==========================================
            // Player Markers
            // ==========================================

            // Proxy through our server to avoid CORS issues with the external API
            const PLAYER_HEAD_API = `${API_BASE}/players`;
            const PLAYER_REFRESH_INTERVAL = 2000; // Refresh every 2 seconds
            const PLAYER_LERP_DURATION = 1000; // Duration for smooth position transitions (ms)
            const CHAT_BUBBLE_DURATION = 10000; // How long chat bubbles stay visible (ms)

            /**
             * Linear interpolation between two values
             */
            function lerp(start, end, t) {
                return start + (end - start) * t;
            }

            /**
             * Smooth easing function (ease-out cubic)
             */
            function easeOutCubic(t) {
                return 1 - Math.pow(1 - t, 3);
            }

            /**
             * Update all player marker positions with smooth lerping
             */
            function updatePlayerLerp(timestamp) {
                let anyAnimating = false;

                for (const [name, data] of playerMarkers) {
                    if (!data.targetPos || !data.startPos || !data.lerpStartTime) continue;

                    const elapsed = timestamp - data.lerpStartTime;
                    const progress = Math.min(elapsed / PLAYER_LERP_DURATION, 1);
                    const easedProgress = easeOutCubic(progress);

                    if (progress < 1) {
                        anyAnimating = true;
                        // Interpolate position
                        const lat = lerp(data.startPos.lat, data.targetPos.lat, easedProgress);
                        const lng = lerp(data.startPos.lng, data.targetPos.lng, easedProgress);
                        data.currentPos = { lat, lng };
                        data.marker.setLatLng([lat, lng]);
                    } else {
                        // Animation complete, snap to target
                        data.currentPos = { ...data.targetPos };
                        data.marker.setLatLng([data.targetPos.lat, data.targetPos.lng]);
                        data.startPos = null;
                        data.lerpStartTime = null;
                    }
                }

                if (anyAnimating) {
                    playerAnimationFrame = requestAnimationFrame(updatePlayerLerp);
                } else {
                    playerAnimationFrame = null;
                }
            }

            /**
             * Start the player lerp animation loop if not already running
             */
            function startPlayerLerpAnimation() {
                if (!playerAnimationFrame) {
                    playerAnimationFrame = requestAnimationFrame(updatePlayerLerp);
                }
            }

            // Default fallback head SVG
            const DEFAULT_HEAD_SVG =
                'data:image/svg+xml,' +
                encodeURIComponent(
                    `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect fill="#8B4513" width="32" height="32"/><rect fill="#F5DEB3" x="8" y="8" width="16" height="16"/></svg>`
                );

            // Icon class names for the spritesheet
            const ICON_CLASSES = {
                heart: { full: 'heart-full', half: 'heart-half', empty: 'heart-empty' },
                hunger: { full: 'hunger-full', half: 'hunger-half', empty: 'hunger-empty' },
                armor: { full: 'armor-full', half: 'armor-half', empty: 'armor-empty' },
            };

            /**
             * Generate stat icons HTML for a given value (0-20 scale)
             * @param {number} value - Current value (0-20)
             * @param {number} maxValue - Maximum value (typically 20)
             * @param {object} iconClasses - Object with full, half, empty class names
             * @returns {string} HTML string with icons
             */
            function generateStatIcons(value, maxValue, iconClasses) {
                const totalIcons = Math.ceil(maxValue / 2); // 10 icons for 20 points
                const fullIcons = Math.floor(value / 2);
                const hasHalf = value % 2 >= 1;
                const emptyIcons = totalIcons - fullIcons - (hasHalf ? 1 : 0);

                let html = '';
                for (let i = 0; i < fullIcons; i++) {
                    html += `<span class="stat-icon ${iconClasses.full}"></span>`;
                }
                if (hasHalf) {
                    html += `<span class="stat-icon ${iconClasses.half}"></span>`;
                }
                for (let i = 0; i < emptyIcons; i++) {
                    html += `<span class="stat-icon ${iconClasses.empty}"></span>`;
                }
                return html;
            }

            /**
             * Create the popup content for a player
             */
            function createPlayerPopupContent(player) {
                const headUrl = getPlayerHeadUrl(player.playfabId);
                const coords = `X: ${Math.floor(player.x)}, Y: ${Math.floor(player.y)}, Z: ${Math.floor(player.z)}`;

                let statsHtml = '';
                if (player.stats) {
                    const healthIcons = generateStatIcons(
                        player.stats.health,
                        player.stats.maxHealth || 20,
                        ICON_CLASSES.heart
                    );
                    const hungerIcons = generateStatIcons(player.stats.hunger, 20, ICON_CLASSES.hunger);
                    const armorIcons = generateStatIcons(player.stats.armor, 20, ICON_CLASSES.armor);

                    statsHtml = `
                        <div class="player-stats-row">
                            <span class="player-stats-label">Health:</span>
                            <div class="player-stats-icons">${healthIcons}</div>
                        </div>
                        <div class="player-stats-row">
                            <span class="player-stats-label">Hunger:</span>
                            <div class="player-stats-icons">${hungerIcons}</div>
                        </div>
                        <div class="player-stats-row">
                            <span class="player-stats-label">Armor:</span>
                            <div class="player-stats-icons">${armorIcons}</div>
                        </div>
                    `;
                } else {
                    statsHtml = '<div class="player-stats-unavailable">Stats not available</div>';
                }

                return `
                    <div class="player-popup">
                        <div class="player-popup-header">
                            <img class="player-popup-head" src="${headUrl}" alt="${player.name}" onerror="this.src='${DEFAULT_HEAD_SVG}'">
                            <div>
                                <div class="player-popup-name">${player.name}</div>
                                <div class="player-popup-coords">${coords}</div>
                            </div>
                        </div>
                        ${statsHtml}
                    </div>
                `;
            }

            /**
             * Get the player head image URL using their PlayFab ID
             */
            function getPlayerHeadUrl(playfabId) {
                if (!playfabId) {
                    return DEFAULT_HEAD_SVG;
                }
                // Use our server proxy to fetch the head image
                return `${PLAYER_HEAD_API}/head/${playfabId}`;
            }

            /**
             * Create a player marker element
             */
            function createPlayerMarkerHtml(player) {
                const headUrl = getPlayerHeadUrl(player.playfabId);
                return `
        <div class="player-marker" data-player-name="${player.name}">
          <div class="player-chat-bubble" data-bubble-for="${player.name}"></div>
          <img class="player-head" src="${headUrl}" alt="${player.name}" onerror="this.src='data:image/svg+xml,${encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32"><rect fill="#8B4513" width="32" height="32"/><rect fill="#F5DEB3" x="8" y="8" width="16" height="16"/></svg>')}'">
          <span class="player-name">${player.name}</span>
        </div>
      `;
            }

            /**
             * Show a chat bubble on a player's marker
             */
            function showPlayerChatBubble(playerName, message) {
                // Find the bubble element for this player
                const bubble = document.querySelector(`.player-chat-bubble[data-bubble-for="${playerName}"]`);
                if (!bubble) return;

                // Truncate long messages
                const displayMessage = message.length > 100 ? message.substring(0, 100) + '...' : message;
                bubble.textContent = displayMessage;
                bubble.classList.add('visible');

                // Clear any existing timeout for this player
                if (chatBubbleTimeouts.has(playerName)) {
                    clearTimeout(chatBubbleTimeouts.get(playerName));
                }

                // Set timeout to hide the bubble
                const timeoutId = setTimeout(() => {
                    bubble.classList.remove('visible');
                    chatBubbleTimeouts.delete(playerName);
                }, CHAT_BUBBLE_DURATION);

                chatBubbleTimeouts.set(playerName, timeoutId);
            }

            /**
             * Update player markers on the map
             */
            function updatePlayerMarkers(players) {
                const currentDimension = document.getElementById('tile-dim').value;

                // Filter players by current dimension
                const dimensionPlayers = players.filter(p => p.dimension === currentDimension);

                // Track which players we've seen in this update
                const seenPlayers = new Set();

                dimensionPlayers.forEach(player => {
                    seenPlayers.add(player.name);

                    // Convert Minecraft coords to Leaflet coords
                    const latLng = minecraftToLeaflet(player.x, player.z);
                    const targetPos = { lat: latLng.lat, lng: latLng.lng };

                    if (playerMarkers.has(player.name)) {
                        // Update existing marker - set up lerp animation
                        const data = playerMarkers.get(player.name);

                        // Only start a new lerp if the target position has changed
                        if (
                            !data.targetPos ||
                            Math.abs(data.targetPos.lat - targetPos.lat) > 0.0001 ||
                            Math.abs(data.targetPos.lng - targetPos.lng) > 0.0001
                        ) {
                            // Start lerp from current position (or current target if mid-animation)
                            data.startPos = data.currentPos ? { ...data.currentPos } : targetPos;
                            data.targetPos = targetPos;
                            data.lerpStartTime = performance.now();

                            // Start the animation loop
                            startPlayerLerpAnimation();
                        }

                        // Update the popup content if it exists
                        if (data.marker.getPopup()) {
                            data.marker.setPopupContent(createPlayerPopupContent(player));
                        }

                        // Store updated player data for popup updates
                        data.player = player;
                    } else {
                        // Create new marker
                        const icon = L.divIcon({
                            html: createPlayerMarkerHtml(player),
                            className: '',
                            iconSize: [60, 60],
                            iconAnchor: [30, 30],
                        });

                        const marker = L.marker(latLng, { icon, interactive: true }).bindPopup(
                            createPlayerPopupContent(player),
                            { className: 'player-popup-container', maxWidth: 360, offset: [0, -15] }
                        );

                        if (playersVisible) {
                            marker.addTo(map);
                        }

                        // Store marker data with position tracking for lerping
                        playerMarkers.set(player.name, {
                            marker,
                            player,
                            currentPos: targetPos,
                            targetPos: targetPos,
                            startPos: null,
                            lerpStartTime: null,
                        });
                    }
                });

                // Remove markers for players no longer in this dimension or offline
                for (const [name, data] of playerMarkers) {
                    if (!seenPlayers.has(name)) {
                        map.removeLayer(data.marker);
                        playerMarkers.delete(name);
                    }
                }
            }

            /**
             * Update the player list in the sidebar
             */
            function updatePlayerList(players) {
                const selectedDimension = document.getElementById('tile-dim').value;
                const showAllDimensions = document.getElementById('show-all-dimensions').checked;
                const listEl = document.getElementById('player-list');
                const countEl = document.getElementById('player-count');

                const dimensionPlayers = players.filter(p => p.dimension === selectedDimension);
                const displayPlayers = showAllDimensions ? players : dimensionPlayers;
                const totalPlayers = players.length;

                if (showAllDimensions) {
                    countEl.textContent = `${totalPlayers} player${totalPlayers !== 1 ? 's' : ''} online`;
                } else {
                    countEl.textContent = `${dimensionPlayers.length} in ${DIMENSION_CONFIG[selectedDimension].name} (${totalPlayers} total)`;
                }

                listEl.innerHTML = displayPlayers
                    .map(player => {
                        const headUrl = getPlayerHeadUrl(player.playfabId);
                        const isOtherDimension = player.dimension !== selectedDimension;
                        const dimBadge =
                            showAllDimensions || isOtherDimension
                                ? `<span class="player-dimension-badge ${player.dimension}">${DIMENSION_CONFIG[player.dimension]?.icon || ''}</span>`
                                : '';
                        const clickAction = isOtherDimension
                            ? `selectDimension('${player.dimension}'); setTimeout(() => panToPlayer('${player.name}'), 100);`
                            : `panToPlayer('${player.name}')`;
                        return `
          <div class="player-list-item" onclick="${clickAction}" title="${isOtherDimension ? 'Click to switch dimension and follow' : 'Click to follow'}">
            <img src="${headUrl}" alt="${player.name}" onerror="this.src='data:image/svg+xml,${encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"><rect fill="#8B4513" width="24" height="24"/><rect fill="#F5DEB3" x="6" y="6" width="12" height="12"/></svg>')}'">
            <div class="player-info">
              <div>${player.name}${dimBadge}</div>
              <div class="player-coords">X: ${Math.floor(player.x)}, Z: ${Math.floor(player.z)}</div>
            </div>
          </div>
        `;
                    })
                    .join('');
            }

            /**
             * Pan the map to a specific player
             */
            function panToPlayer(name) {
                const player = currentPlayers.find(p => p.name === name);
                if (player) {
                    const latLng = minecraftToLeaflet(player.x, player.z);
                    map.setView(latLng, Math.max(map.getZoom(), 4)); // Zoom in a bit when panning to player
                }
            }

            /**
             * Fetch players from the API
             */
            async function fetchPlayers() {
                try {
                    const response = await fetch(`${API_BASE}/players`);
                    if (!response.ok) throw new Error('Failed to fetch players');

                    const data = await response.json();
                    if (data.success && data.data && data.data.players) {
                        currentPlayers = data.data.players;
                        updatePlayerMarkers(currentPlayers);
                        updatePlayerList(currentPlayers);
                    }
                } catch (error) {
                    console.error('Error fetching players:', error);
                }
            }

            /**
             * Toggle player visibility
             */
            function setPlayersVisible(visible) {
                playersVisible = visible;
                for (const data of playerMarkers.values()) {
                    if (visible) {
                        data.marker.addTo(map);
                    } else {
                        map.removeLayer(data.marker);
                    }
                }
            }

            // Event listeners for player visibility
            document.getElementById('show-players').addEventListener('change', function () {
                setPlayersVisible(this.checked);
            });

            // Refresh markers when dimension changes
            document.getElementById('tile-dim').addEventListener('change', () => {
                // Clear all current markers and refetch
                for (const data of playerMarkers.values()) {
                    map.removeLayer(data.marker);
                }
                playerMarkers.clear();
                updatePlayerMarkers(currentPlayers);
                updatePlayerList(currentPlayers);
            });

            // Show all dimensions toggle
            document.getElementById('show-all-dimensions').addEventListener('change', () => {
                updatePlayerList(currentPlayers);
            });

            // ==========================================
            // Spawn Markers
            // ==========================================

            /**
             * Create HTML for world spawn marker (home icon)
             */
            function createWorldSpawnMarkerHtml() {
                return `
                    <div class="spawn-marker">
                        <span class="spawn-icon">üè†</span>
                        <span class="spawn-label world-spawn">World Spawn</span>
                    </div>
                `;
            }

            /**
             * Create HTML for player spawn marker (bed icon)
             */
            function createPlayerSpawnMarkerHtml() {
                return `
                    <div class="spawn-marker">
                        <span class="spawn-icon">üõèÔ∏è</span>
                    </div>
                `;
            }

            /**
             * Update the world spawn marker
             */
            function updateWorldSpawnMarker(spawn) {
                if (!spawn) {
                    // Remove marker if no spawn
                    if (worldSpawnMarker) {
                        map.removeLayer(worldSpawnMarker);
                        worldSpawnMarker = null;
                    }
                    return;
                }

                currentWorldSpawn = spawn;
                const currentDimension = document.getElementById('tile-dim').value;

                // Only show if in the same dimension
                if (spawn.dimension !== currentDimension) {
                    if (worldSpawnMarker) {
                        map.removeLayer(worldSpawnMarker);
                        worldSpawnMarker = null;
                    }
                    return;
                }

                const latLng = minecraftToLeaflet(spawn.x, spawn.z);

                if (worldSpawnMarker) {
                    // Update existing marker position
                    worldSpawnMarker.setLatLng(latLng);
                } else {
                    // Create new marker
                    const icon = L.divIcon({
                        html: createWorldSpawnMarkerHtml(),
                        className: '',
                        iconSize: [60, 40],
                        iconAnchor: [30, 20],
                    });

                    worldSpawnMarker = L.marker(latLng, { icon, interactive: true }).bindPopup(
                        `<b>World Spawn</b><br>X: ${Math.floor(spawn.x)}, Y: ${Math.floor(spawn.y)}, Z: ${Math.floor(spawn.z)}`
                    );

                    if (spawnsVisible) {
                        worldSpawnMarker.addTo(map);
                    }
                }
            }

            /**
             * Update player spawn markers
             */
            function updatePlayerSpawnMarkers(spawns) {
                currentPlayerSpawns = spawns;
                const currentDimension = document.getElementById('tile-dim').value;

                // Filter spawns by current dimension
                const dimensionSpawns = spawns.filter(s => s.dimension === currentDimension);

                // Track which players we've seen
                const seenPlayers = new Set();

                dimensionSpawns.forEach(spawn => {
                    seenPlayers.add(spawn.playerName);

                    const latLng = minecraftToLeaflet(spawn.x, spawn.z);

                    if (playerSpawnMarkers.has(spawn.playerName)) {
                        // Update existing marker
                        const marker = playerSpawnMarkers.get(spawn.playerName);
                        marker.setLatLng(latLng);
                        marker.setPopupContent(
                            `<b>${spawn.playerName}'s Bed</b><br>X: ${Math.floor(spawn.x)}, Y: ${Math.floor(spawn.y)}, Z: ${Math.floor(spawn.z)}`
                        );
                    } else {
                        // Create new marker
                        const icon = L.divIcon({
                            html: createPlayerSpawnMarkerHtml(),
                            className: '',
                            iconSize: [80, 40],
                            iconAnchor: [40, 20],
                        });

                        const marker = L.marker(latLng, { icon, interactive: true }).bindPopup(
                            `<b>${spawn.playerName}'s Bed</b><br>X: ${Math.floor(spawn.x)}, Y: ${Math.floor(spawn.y)}, Z: ${Math.floor(spawn.z)}`
                        );

                        if (spawnsVisible) {
                            marker.addTo(map);
                        }

                        playerSpawnMarkers.set(spawn.playerName, marker);
                    }
                });

                // Remove markers for players no longer in this dimension
                for (const [playerName, marker] of playerSpawnMarkers) {
                    if (!seenPlayers.has(playerName)) {
                        map.removeLayer(marker);
                        playerSpawnMarkers.delete(playerName);
                    }
                }
            }

            /**
             * Toggle spawn marker visibility
             */
            function setSpawnsVisible(visible) {
                spawnsVisible = visible;

                if (worldSpawnMarker) {
                    if (visible) {
                        worldSpawnMarker.addTo(map);
                    } else {
                        map.removeLayer(worldSpawnMarker);
                    }
                }

                for (const marker of playerSpawnMarkers.values()) {
                    if (visible) {
                        marker.addTo(map);
                    } else {
                        map.removeLayer(marker);
                    }
                }
            }

            /**
             * Refresh spawn markers when dimension changes
             */
            function refreshSpawnMarkers() {
                // Clear current markers
                if (worldSpawnMarker) {
                    map.removeLayer(worldSpawnMarker);
                    worldSpawnMarker = null;
                }
                for (const marker of playerSpawnMarkers.values()) {
                    map.removeLayer(marker);
                }
                playerSpawnMarkers.clear();

                // Re-render with current data
                updateWorldSpawnMarker(currentWorldSpawn);
                updatePlayerSpawnMarkers(currentPlayerSpawns);
            }

            /**
             * Fetch spawns from the API
             */
            async function fetchSpawns() {
                try {
                    const response = await fetch(`${API_BASE}/spawns`);
                    if (!response.ok) throw new Error('Failed to fetch spawns');

                    const data = await response.json();
                    if (data.success && data.data) {
                        if (data.data.worldSpawn) {
                            updateWorldSpawnMarker(data.data.worldSpawn);
                        }
                        if (data.data.playerSpawns) {
                            updatePlayerSpawnMarkers(data.data.playerSpawns);
                        }
                    }
                } catch (error) {
                    console.error('Error fetching spawns:', error);
                }
            }

            // Event listener for spawn visibility toggle
            document.getElementById('show-spawns').addEventListener('change', function () {
                setSpawnsVisible(this.checked);
            });

            // Refresh spawn markers when dimension changes
            document.getElementById('tile-dim').addEventListener('change', () => {
                refreshSpawnMarkers();
            });

            // ==========================================
            // Chat Messages
            // ==========================================

            const MAX_CHAT_MESSAGES = 100; // Maximum messages to keep in memory
            let chatMessages = [];

            /**
             * Format a timestamp for display
             */
            function formatChatTime(timestamp) {
                const date = new Date(timestamp);
                return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            }

            /**
             * Get dimension display name
             */
            function getDimensionDisplayName(dimension) {
                switch (dimension) {
                    case 'overworld':
                        return 'Overworld';
                    case 'nether':
                        return 'Nether';
                    case 'the_end':
                        return 'The End';
                    default:
                        return dimension;
                }
            }

            /**
             * Create HTML for a single chat message
             */
            function createChatMessageHtml(chat) {
                const time = formatChatTime(chat.timestamp);
                const dimensionName = getDimensionDisplayName(chat.dimension);

                return `
                    <div class="chat-message">
                        <div class="chat-message-header">
                            <span class="chat-player">${escapeHtml(chat.playerName)}</span>
                            <span class="chat-time">${time}</span>
                        </div>
                        <div class="chat-text">${escapeHtml(chat.message)}</div>
                        <span class="chat-dimension">${dimensionName}</span>
                    </div>
                `;
            }

            /**
             * Escape HTML special characters to prevent XSS
             */
            function escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            /**
             * Add a new chat message to the display
             */
            function addChatMessage(chat) {
                chatMessages.push(chat);

                // Limit stored messages
                if (chatMessages.length > MAX_CHAT_MESSAGES) {
                    chatMessages = chatMessages.slice(-MAX_CHAT_MESSAGES);
                }

                updateChatDisplay();

                // Show chat bubble on the player's marker
                if (chat.playerName && chat.message) {
                    showPlayerChatBubble(chat.playerName, chat.message);
                }
            }

            /**
             * Load chat history (replaces current messages)
             */
            function loadChatHistory(messages) {
                // Replace current messages with history
                chatMessages = [...messages];

                // Limit to max
                if (chatMessages.length > MAX_CHAT_MESSAGES) {
                    chatMessages = chatMessages.slice(-MAX_CHAT_MESSAGES);
                }

                updateChatDisplay();
            }

            /**
             * Update the chat messages display
             */
            function updateChatDisplay() {
                const container = document.getElementById('chat-messages');
                const countEl = document.getElementById('chat-count');

                if (chatMessages.length === 0) {
                    container.innerHTML = '<div class="chat-empty">No messages yet...</div>';
                    countEl.textContent = '0 messages';
                    return;
                }

                // Show messages in reverse order (newest at bottom, scroll to bottom)
                container.innerHTML = chatMessages.map(createChatMessageHtml).join('');
                countEl.textContent = `${chatMessages.length} message${chatMessages.length !== 1 ? 's' : ''}`;

                // Auto-scroll to bottom
                container.scrollTop = container.scrollHeight;
            }

            // ==========================================
            // WebSocket for Real-time Updates
            // ==========================================

            let ws = null;
            let wsReconnectTimer = null;
            let wsConnected = false;
            const WS_RECONNECT_DELAY = 3000;

            /**
             * Create WebSocket URL based on current page location
             */
            function getWebSocketUrl() {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                return `${protocol}//${window.location.host}/ws`;
            }

            /**
             * Connect to WebSocket server
             */
            function connectWebSocket() {
                if (ws && (ws.readyState === WebSocket.CONNECTING || ws.readyState === WebSocket.OPEN)) {
                    return; // Already connected or connecting
                }

                const url = getWebSocketUrl();
                console.log('[WebSocket] Connecting to', url);

                try {
                    ws = new WebSocket(url);

                    ws.onopen = () => {
                        console.log('[WebSocket] Connected');
                        wsConnected = true;
                        updateConnectionStatus(true);

                        // Clear any reconnect timer
                        if (wsReconnectTimer) {
                            clearTimeout(wsReconnectTimer);
                            wsReconnectTimer = null;
                        }
                    };

                    ws.onclose = () => {
                        console.log('[WebSocket] Disconnected');
                        wsConnected = false;
                        updateConnectionStatus(false);

                        // Schedule reconnect
                        if (!wsReconnectTimer) {
                            wsReconnectTimer = setTimeout(() => {
                                wsReconnectTimer = null;
                                connectWebSocket();
                            }, WS_RECONNECT_DELAY);
                        }
                    };

                    ws.onerror = error => {
                        console.error('[WebSocket] Error:', error);
                    };

                    ws.onmessage = event => {
                        try {
                            const data = JSON.parse(event.data);
                            handleWebSocketEvent(data);
                        } catch (error) {
                            console.error('[WebSocket] Failed to parse message:', error);
                        }
                    };
                } catch (error) {
                    console.error('[WebSocket] Failed to create connection:', error);
                }
            }

            /**
             * Handle incoming WebSocket events
             */
            function handleWebSocketEvent(event) {
                const { type } = event;

                switch (type) {
                    case 'connection:established':
                        console.log('[WebSocket] Connection established:', event.message);
                        break;

                    case 'player:update':
                        // Update player positions
                        if (event.players && Array.isArray(event.players)) {
                            // Merge with existing players
                            for (const player of event.players) {
                                const index = currentPlayers.findIndex(p => p.name === player.name);
                                if (index >= 0) {
                                    currentPlayers[index] = player;
                                } else {
                                    currentPlayers.push(player);
                                }
                            }
                            updatePlayerMarkers(currentPlayers);
                            updatePlayerList(currentPlayers);
                        }
                        break;

                    case 'player:join':
                        // Add new player
                        if (event.player) {
                            const existingIndex = currentPlayers.findIndex(p => p.name === event.player.name);
                            if (existingIndex >= 0) {
                                currentPlayers[existingIndex] = event.player;
                            } else {
                                currentPlayers.push(event.player);
                            }
                            updatePlayerMarkers(currentPlayers);
                            updatePlayerList(currentPlayers);
                            console.log('[WebSocket] Player joined:', event.player.name);
                        }
                        break;

                    case 'player:leave':
                        // Remove player
                        if (event.playerName) {
                            currentPlayers = currentPlayers.filter(p => p.name !== event.playerName);
                            // Remove marker
                            const data = playerMarkers.get(event.playerName);
                            if (data) {
                                map.removeLayer(data.marker);
                                playerMarkers.delete(event.playerName);
                            }
                            updatePlayerList(currentPlayers);
                            console.log('[WebSocket] Player left:', event.playerName);
                        }
                        break;

                    case 'tile:update':
                        // Refresh affected tiles
                        if (event.tiles && Array.isArray(event.tiles)) {
                            handleTileUpdates(event.tiles);
                        }
                        break;

                    case 'chat:message':
                        // Handle chat message
                        if (event.chat) {
                            addChatMessage(event.chat);
                            console.log('[WebSocket] Chat message from:', event.chat.playerName);
                        }
                        break;

                    case 'chat:history':
                        // Handle chat history (sent on connection)
                        if (event.messages && Array.isArray(event.messages)) {
                            loadChatHistory(event.messages);
                            console.log('[WebSocket] Loaded chat history:', event.messages.length, 'messages');
                        }
                        break;

                    case 'spawn:world':
                        // Handle world spawn update
                        if (event.spawn) {
                            updateWorldSpawnMarker(event.spawn);
                            console.log('[WebSocket] World spawn updated:', event.spawn);
                        }
                        break;

                    case 'spawn:player':
                        // Handle player spawn update
                        if (event.spawn) {
                            // Update the spawn in our current list
                            const existingIndex = currentPlayerSpawns.findIndex(
                                s => s.playerName === event.spawn.playerName
                            );
                            if (existingIndex >= 0) {
                                currentPlayerSpawns[existingIndex] = event.spawn;
                            } else {
                                currentPlayerSpawns.push(event.spawn);
                            }
                            updatePlayerSpawnMarkers(currentPlayerSpawns);
                            console.log('[WebSocket] Player spawn updated:', event.spawn.playerName);
                        }
                        break;

                    case 'spawn:state':
                        // Handle full spawn state (sent on connection)
                        if (event.worldSpawn) {
                            updateWorldSpawnMarker(event.worldSpawn);
                        }
                        if (event.playerSpawns && Array.isArray(event.playerSpawns)) {
                            currentPlayerSpawns = event.playerSpawns;
                            updatePlayerSpawnMarkers(event.playerSpawns);
                        }
                        console.log(
                            '[WebSocket] Loaded spawn state:',
                            event.worldSpawn ? 'world spawn' : 'no world spawn',
                            ',',
                            event.playerSpawns?.length || 0,
                            'player spawns'
                        );
                        break;

                    case 'time:update':
                        // Handle world time update
                        if (event.time) {
                            handleTimeSync(event.time);
                        }
                        break;

                    case 'time:state':
                        // Handle world time state (sent on connection)
                        if (event.time) {
                            handleTimeSync(event.time);
                            console.log(
                                '[WebSocket] Loaded time state: day',
                                event.time.day,
                                'timeOfDay',
                                event.time.timeOfDay
                            );
                        }
                        break;

                    case 'weather:update':
                        // Handle world weather update
                        if (event.weather) {
                            handleWeatherSync(event.weather);
                            console.log('[WebSocket] Weather changed to:', event.weather.weather);
                        }
                        break;

                    case 'weather:state':
                        // Handle world weather state (sent on connection)
                        if (event.weather) {
                            handleWeatherSync(event.weather);
                            console.log('[WebSocket] Loaded weather state:', event.weather.weather);
                        }
                        break;

                    default:
                        console.log('[WebSocket] Unknown event type:', type);
                }
            }

            /**
             * Handle tile update events - refresh only the specific tiles that changed
             */
            function handleTileUpdates(tiles) {
                const currentDimension = document.getElementById('tile-dim').value;
                const currentMapType = document.getElementById('tile-map-type').value;
                // Get the current server zoom level based on Leaflet zoom
                const currentServerZoom = MAX_ZOOM - Math.round(map.getZoom());

                // Filter to tiles in current dimension, map type, and at our display zoom level
                const relevantTiles = tiles.filter(
                    tile =>
                        tile.dimension === currentDimension &&
                        tile.zoom === currentServerZoom &&
                        (tile.mapType === currentMapType || tile.mapType === undefined)
                );

                if (relevantTiles.length === 0) {
                    return;
                }

                // Refresh only the specific tiles that were updated
                if (tileLayer && tileLayer.refresh) {
                    tileLayer.refresh(relevantTiles);
                }
            }

            /**
             * Update the connection status indicator
             */
            function updateConnectionStatus(connected) {
                let statusEl = document.getElementById('ws-status');
                if (!statusEl) {
                    // Create status indicator if it doesn't exist
                    statusEl = document.createElement('div');
                    statusEl.id = 'ws-status';
                    statusEl.style.cssText = `
                        position: absolute;
                        top: 10px;
                        right: 10px;
                        padding: 6px 12px;
                        border-radius: 4px;
                        font-size: 12px;
                        z-index: 1000;
                        pointer-events: none;
                    `;
                    document.querySelector('.map-container').appendChild(statusEl);
                }

                if (connected) {
                    statusEl.style.background = 'rgba(46, 204, 113, 0.9)';
                    statusEl.style.color = '#fff';
                    statusEl.textContent = '‚óè Live';
                } else {
                    statusEl.style.background = 'rgba(231, 76, 60, 0.9)';
                    statusEl.style.color = '#fff';
                    statusEl.textContent = '‚óã Reconnecting...';
                }
            }

            // Initial fetch (before WebSocket connects)
            fetchPlayers();
            fetchSpawns();

            // Initialize the clock display
            updateClockDisplay();

            // Initialize the weather display
            updateWeatherDisplay();

            // Connect to WebSocket
            connectWebSocket();

            // Fallback polling - only if WebSocket is not connected
            // Reduced frequency since WebSocket handles real-time updates
            setInterval(() => {
                if (!wsConnected) {
                    fetchPlayers();
                    fetchSpawns();
                }
            }, PLAYER_REFRESH_INTERVAL * 2);
        </script>
    </body>
</html>
