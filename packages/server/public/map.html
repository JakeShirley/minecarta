<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Map Viewer - Minecraft Map API</title>
        <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
        <style>
            * {
                box-sizing: border-box;
            }
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                margin: 0;
                padding: 0;
                background: #1a1a2e;
                color: #eee;
                height: 100vh;
                display: flex;
                flex-direction: column;
            }
            header {
                background: #0f3460;
                padding: 10px 20px;
                display: flex;
                align-items: center;
                justify-content: space-between;
                border-bottom: 1px solid #1f4068;
            }
            h1 {
                margin: 0;
                font-size: 1.2rem;
                color: #6dd5ed;
            }
            .nav-btn {
                background: #16213e;
                color: #6dd5ed;
                text-decoration: none;
                padding: 8px 12px;
                border-radius: 4px;
                border: 1px solid #6dd5ed;
                font-size: 0.9rem;
            }
            .nav-btn:hover {
                background: #6dd5ed;
                color: #16213e;
            }

            main {
                flex: 1;
                display: flex;
                overflow: hidden;
            }

            .sidebar {
                width: 300px;
                background: #16213e;
                border-right: 1px solid #0f3460;
                padding: 15px;
                overflow-y: auto;
                display: flex;
                flex-direction: column;
                gap: 20px;
            }

            .map-container {
                flex: 1;
                position: relative;
            }

            #map {
                width: 100%;
                height: 100%;
                background: #000;
            }

            /* Disable image smoothing for crisp pixel-art tiles */
            #map img,
            .leaflet-tile,
            #tile-preview {
                image-rendering: pixelated;
                image-rendering: -moz-crisp-edges;
                image-rendering: crisp-edges;
            }

            /* Coordinate display */
            .coord-display {
                position: absolute;
                bottom: 10px;
                left: 10px;
                background: rgba(15, 52, 96, 0.9);
                color: #6dd5ed;
                padding: 8px 12px;
                border-radius: 4px;
                font-family: 'Consolas', 'Monaco', monospace;
                font-size: 14px;
                z-index: 1000;
                border: 1px solid #1f4068;
                pointer-events: none;
            }
            .coord-display .label {
                color: #888;
                font-size: 11px;
            }

            /* Grid line styling */
            .coord-grid-canvas {
                position: absolute;
                top: 0;
                left: 0;
                pointer-events: none;
                z-index: 500;
            }

            /* Grid labels */
            .grid-label {
                position: absolute;
                background: rgba(15, 52, 96, 0.9);
                color: #6dd5ed;
                padding: 2px 6px;
                border-radius: 3px;
                font-family: 'Consolas', 'Monaco', monospace;
                font-size: 11px;
                white-space: nowrap;
                border: 1px solid #1f4068;
                pointer-events: none;
                z-index: 501;
            }

            /* Player markers */
            .player-marker {
                display: flex;
                flex-direction: column;
                align-items: center;
                pointer-events: auto;
            }
            .player-head {
                width: 32px;
                height: 32px;
                border: 2px solid #6dd5ed;
                border-radius: 4px;
                background: #16213e;
                image-rendering: pixelated;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
            }
            .player-name {
                margin-top: 4px;
                background: rgba(15, 52, 96, 0.9);
                color: #6dd5ed;
                padding: 2px 6px;
                border-radius: 3px;
                font-family: 'Consolas', 'Monaco', monospace;
                font-size: 11px;
                white-space: nowrap;
                border: 1px solid #1f4068;
            }

            /* Player list in sidebar */
            .player-list {
                max-height: 200px;
                overflow-y: auto;
            }
            .player-list-item {
                display: flex;
                align-items: center;
                gap: 8px;
                padding: 6px;
                background: #0f3460;
                border-radius: 4px;
                margin-bottom: 4px;
                cursor: pointer;
                transition: background 0.2s;
            }
            .player-list-item:hover {
                background: #1f4068;
            }
            .player-list-item img {
                width: 24px;
                height: 24px;
                border-radius: 3px;
                image-rendering: pixelated;
            }
            .player-list-item .player-info {
                flex: 1;
                font-size: 0.85rem;
            }
            .player-list-item .player-coords {
                font-size: 0.7rem;
                color: #888;
            }
            .player-count {
                font-size: 0.8rem;
                color: #888;
                margin-bottom: 8px;
            }

            .control-group {
                margin-bottom: 15px;
            }
            label {
                display: block;
                margin-bottom: 5px;
                color: #ccc;
                font-size: 0.9rem;
            }
            input,
            select {
                width: 100%;
                background: #0f3460;
                border: 1px solid #1f4068;
                color: white;
                padding: 6px;
                border-radius: 4px;
            }
            button {
                background: #e94560;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 4px;
                cursor: pointer;
                width: 100%;
                margin-top: 5px;
            }
            button:hover {
                background: #ff6b81;
            }

            /* Tile Preview */
            .tile-preview-container {
                margin-top: 20px;
                border-top: 1px solid #0f3460;
                padding-top: 20px;
            }
            #tile-preview {
                width: 100%;
                aspect-ratio: 1;
                border: 1px solid #e94560;
                background-color: #000;
                background-image:
                    linear-gradient(45deg, #222 25%, transparent 25%),
                    linear-gradient(-45deg, #222 25%, transparent 25%),
                    linear-gradient(45deg, transparent 75%, #222 75%),
                    linear-gradient(-45deg, transparent 75%, #222 75%);
                background-size: 20px 20px;
                margin-bottom: 5px;
                display: block;
            }
            .tile-info {
                font-family: monospace;
                font-size: 0.8rem;
                color: #888;
                word-break: break-all;
            }
        </style>
    </head>
    <body>
        <header>
            <h1>üó∫Ô∏è Map Viewer</h1>
            <div style="display: flex; gap: 10px">
                <a href="api-tester.html" class="nav-btn">API Tester</a>
                <a href="index.html" class="nav-btn">Home</a>
            </div>
        </header>

        <main>
            <div class="sidebar">
                <div class="control-group">
                    <label>Dimension</label>
                    <select id="tile-dim">
                        <option value="overworld">Overworld</option>
                        <option value="nether">Nether</option>
                        <option value="the_end">The End</option>
                    </select>
                </div>

                <div class="control-group">
                    <button onclick="updateMapLayer()">Refresh Map Layer</button>
                </div>

                <div class="control-group">
                    <label style="display: flex; align-items: center; gap: 8px">
                        <input type="checkbox" id="show-grid" checked style="width: auto" /> Show Coordinate Grid
                    </label>
                </div>

                <div class="control-group">
                    <label style="display: flex; align-items: center; gap: 8px">
                        <input type="checkbox" id="show-players" checked style="width: auto" /> Show Players
                    </label>
                </div>

                <div class="control-group">
                    <label>Online Players</label>
                    <div class="player-count" id="player-count">0 players</div>
                    <div class="player-list" id="player-list"></div>
                </div>

                <div class="tile-preview-container">
                    <label>Single Tile Inspector</label>
                    <div style="display: flex; gap: 5px; margin-bottom: 5px">
                        <div style="flex: 1">
                            <label style="font-size: 0.8em">Zoom (0=High)</label
                            ><input type="number" id="preview-z" value="2" min="0" max="7" />
                        </div>
                        <div style="flex: 1">
                            <label style="font-size: 0.8em">X</label><input type="number" id="preview-x" value="0" />
                        </div>
                        <div style="flex: 1">
                            <label style="font-size: 0.8em">Y</label><input type="number" id="preview-y" value="0" />
                        </div>
                    </div>
                    <button onclick="loadTile()">Preview Tile</button>
                    <img id="tile-preview" alt="Tile Preview" />
                    <div class="tile-info" id="tile-url"></div>
                </div>

                <div style="margin-top: auto; font-size: 0.8rem; color: #666">
                    <p>Pan: Drag</p>
                    <p>Zoom: Scroll</p>
                </div>
            </div>

            <div class="map-container">
                <div id="map"></div>
                <div class="coord-display" id="coord-display">
                    <div class="label">Minecraft Coordinates</div>
                    <div id="coord-text">X: 0, Z: 0</div>
                    <div id="zoom-text" style="font-size: 11px; color: #888; margin-top: 4px">Zoom: 3</div>
                </div>
            </div>
        </main>

        <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
        <script>
            const API_BASE = '/api/v1';

            // Server zoom levels: 0 (16 blocks/tile, highest detail) to 7 (2048 blocks/tile)
            // Leaflet: higher zoom = more zoomed in (bigger tiles visually)
            const MAX_ZOOM = 7;

            // Blocks per tile at each server zoom level (must match server constants!)
            // z0: 16 blocks per tile (1 chunk)
            // z4: 256 blocks per tile (1 pixel = 1 block)
            // z6: 1024 blocks per tile
            // z7: 2048 blocks per tile
            const BLOCKS_PER_TILE = {
                0: 16,
                1: 32,
                2: 64,
                3: 128,
                4: 256,
                5: 512,
                6: 1024,
                7: 2048,
            };

            // Base server zoom level used for tiles
            const BASE_SERVER_ZOOM = 4;
            // Blocks per tile at base server zoom
            const BASE_BLOCKS_PER_TILE = BLOCKS_PER_TILE[BASE_SERVER_ZOOM];

            // Map Init
            const map = L.map('map', {
                crs: L.CRS.Simple,
                minZoom: 0,
                maxZoom: MAX_ZOOM,
                center: [0, 0],
                zoom: 3,
                zoomControl: true,
                zoomSnap: 1,
                zoomDelta: 1,
            });

            let tileLayer;

            /**
             * Convert Leaflet coordinates to Minecraft world coordinates
             *
             * In Leaflet CRS.Simple at native zoom 3:
             * - 1 tile = 256 pixels = 32 latlng units (since pixel = latlng * 2^zoom)
             * - 1 tile = 256 blocks (BASE_BLOCKS_PER_TILE at server zoom 4)
             * - Therefore: 32 latlng units = 256 blocks, so 1 latlng = 8 blocks
             *
             * This is zoom-independent - Minecraft coords should be the same at any zoom level.
             */
            function leafletToMinecraft(latlng) {
                // At native zoom 3: 32 latlng units = 256 blocks
                // So blocksPerLatlngUnit = 256 / 32 = 8
                const blocksPerLatlngUnit = BASE_BLOCKS_PER_TILE / 32;

                const mcX = Math.floor(latlng.lng * blocksPerLatlngUnit);
                const mcZ = Math.floor(-latlng.lat * blocksPerLatlngUnit);

                return { x: mcX, z: mcZ };
            }

            /**
             * Convert Minecraft coordinates to Leaflet coordinates
             * This is zoom-independent.
             */
            function minecraftToLeaflet(mcX, mcZ) {
                const blocksPerLatlngUnit = BASE_BLOCKS_PER_TILE / 32;

                const lat = -(mcZ / blocksPerLatlngUnit);
                const lng = mcX / blocksPerLatlngUnit;

                return L.latLng(lat, lng);
            }

            /**
             * Update coordinate display with mouse position
             */
            function updateCoordDisplay(e) {
                const coords = leafletToMinecraft(e.latlng);
                document.getElementById('coord-text').textContent = `X: ${coords.x}, Z: ${coords.z}`;
            }

            /**
             * Update zoom display
             */
            function updateZoomDisplay() {
                const leafletZoom = map.getZoom();
                const nativeLeafletZoom = 3;
                const scale = Math.pow(2, leafletZoom - nativeLeafletZoom);
                const blocksPerTile = Math.round(BASE_BLOCKS_PER_TILE / scale);
                document.getElementById('zoom-text').textContent =
                    `Zoom: ${leafletZoom} (${blocksPerTile} blocks/tile)`;
            }

            map.on('mousemove', updateCoordDisplay);
            map.on('zoomend', updateZoomDisplay);

            /**
             * Canvas-based coordinate grid overlay
             * Draws clean grid lines at regular Minecraft coordinate intervals
             */
            class CoordGridOverlay {
                constructor(map) {
                    this.map = map;
                    this.canvas = null;
                    this.ctx = null;
                    this.labelContainer = null;
                    this.visible = true;
                    this._onMove = this._onMove.bind(this);
                    this._init();
                }

                _init() {
                    // Create canvas for grid lines
                    this.canvas = document.createElement('canvas');
                    this.canvas.className = 'coord-grid-canvas';
                    this.map.getContainer().appendChild(this.canvas);
                    this.ctx = this.canvas.getContext('2d');

                    // Create container for labels
                    this.labelContainer = document.createElement('div');
                    this.labelContainer.style.cssText =
                        'position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:501;overflow:hidden;';
                    this.map.getContainer().appendChild(this.labelContainer);

                    // Bind events
                    this.map.on('move zoom resize zoomend moveend', this._onMove);

                    // Initial render
                    this._resize();
                    this._render();
                }

                _resize() {
                    const container = this.map.getContainer();
                    const rect = container.getBoundingClientRect();
                    this.canvas.width = rect.width;
                    this.canvas.height = rect.height;
                    this.canvas.style.width = rect.width + 'px';
                    this.canvas.style.height = rect.height + 'px';
                }

                _onMove() {
                    this._resize();
                    this._render();
                }

                /**
                 * Choose grid spacing based on zoom level
                 * We want roughly 3-6 grid lines visible on screen
                 */
                _getGridSpacing() {
                    const leafletZoom = this.map.getZoom();
                    const nativeLeafletZoom = 3;
                    const scale = Math.pow(2, leafletZoom - nativeLeafletZoom);
                    const blocksPerPixel = BASE_BLOCKS_PER_TILE / (256 * scale);

                    // Approximate pixels per 1000 blocks
                    const pixelsPer1000Blocks = 1000 / blocksPerPixel;

                    // Choose spacing so we get reasonable number of lines
                    // Prefer nice round numbers in Minecraft coords
                    if (pixelsPer1000Blocks > 800) return 256; // Very zoomed in
                    if (pixelsPer1000Blocks > 400) return 512;
                    if (pixelsPer1000Blocks > 200) return 1024;
                    if (pixelsPer1000Blocks > 100) return 2048;
                    if (pixelsPer1000Blocks > 50) return 4096;
                    if (pixelsPer1000Blocks > 25) return 8192;
                    return 16384; // Very zoomed out
                }

                _render() {
                    if (!this.visible) {
                        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                        this.labelContainer.innerHTML = '';
                        return;
                    }

                    const ctx = this.ctx;
                    const width = this.canvas.width;
                    const height = this.canvas.height;

                    ctx.clearRect(0, 0, width, height);
                    this.labelContainer.innerHTML = '';

                    const spacing = this._getGridSpacing();

                    // Get bounds in Minecraft coordinates
                    const bounds = this.map.getBounds();
                    const topLeft = leafletToMinecraft(bounds.getNorthWest());
                    const bottomRight = leafletToMinecraft(bounds.getSouthEast());

                    // Calculate first grid line positions (round to spacing)
                    const startX = Math.floor(topLeft.x / spacing) * spacing;
                    const endX = Math.ceil(bottomRight.x / spacing) * spacing;
                    const startZ = Math.floor(bottomRight.z / spacing) * spacing;
                    const endZ = Math.ceil(topLeft.z / spacing) * spacing;

                    // Draw settings
                    ctx.strokeStyle = 'rgba(109, 213, 237, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([]);

                    const labels = [];

                    // Draw vertical lines (constant X)
                    for (let mcX = startX; mcX <= endX; mcX += spacing) {
                        const topPoint = minecraftToLeaflet(mcX, topLeft.z);
                        const bottomPoint = minecraftToLeaflet(mcX, bottomRight.z);

                        const topScreen = this.map.latLngToContainerPoint(topPoint);
                        const bottomScreen = this.map.latLngToContainerPoint(bottomPoint);

                        ctx.beginPath();
                        ctx.moveTo(Math.round(topScreen.x) + 0.5, 0);
                        ctx.lineTo(Math.round(bottomScreen.x) + 0.5, height);
                        ctx.stroke();

                        // Add X label at top
                        if (topScreen.x > 30 && topScreen.x < width - 30) {
                            labels.push({ x: topScreen.x, y: 10, text: `X: ${mcX}`, type: 'x' });
                        }
                    }

                    // Draw horizontal lines (constant Z)
                    for (let mcZ = startZ; mcZ <= endZ; mcZ += spacing) {
                        const leftPoint = minecraftToLeaflet(topLeft.x, mcZ);
                        const rightPoint = minecraftToLeaflet(bottomRight.x, mcZ);

                        const leftScreen = this.map.latLngToContainerPoint(leftPoint);
                        const rightScreen = this.map.latLngToContainerPoint(rightPoint);

                        ctx.beginPath();
                        ctx.moveTo(0, Math.round(leftScreen.y) + 0.5);
                        ctx.lineTo(width, Math.round(rightScreen.y) + 0.5);
                        ctx.stroke();

                        // Add Z label at left
                        if (leftScreen.y > 20 && leftScreen.y < height - 20) {
                            labels.push({ x: 10, y: leftScreen.y, text: `Z: ${mcZ}`, type: 'z' });
                        }
                    }

                    // Render labels
                    labels.forEach(label => {
                        const el = document.createElement('div');
                        el.className = 'grid-label';
                        el.textContent = label.text;
                        el.style.left = label.x + 'px';
                        el.style.top = label.y + 'px';
                        if (label.type === 'x') {
                            el.style.transform = 'translateX(-50%)';
                        }
                        this.labelContainer.appendChild(el);
                    });
                }

                setVisible(visible) {
                    this.visible = visible;
                    this.canvas.style.display = visible ? 'block' : 'none';
                    this.labelContainer.style.display = visible ? 'block' : 'none';
                    if (visible) this._render();
                }

                remove() {
                    this.map.off('move zoom resize zoomend moveend', this._onMove);
                    this.canvas.remove();
                    this.labelContainer.remove();
                }
            }

            let gridOverlay = null;

            document.getElementById('show-grid').addEventListener('change', function () {
                if (gridOverlay) {
                    gridOverlay.setVisible(this.checked);
                }
            });

            function updateMapLayer() {
                if (tileLayer) {
                    map.removeLayer(tileLayer);
                }

                const dim = document.getElementById('tile-dim').value;

                L.TileLayer.Minecraft = L.TileLayer.extend({
                    options: {
                        minZoom: 0,
                        maxZoom: MAX_ZOOM,
                        minNativeZoom: 3, // Native tiles available at Leaflet zoom 3
                        maxNativeZoom: 3, // Server zoom 4
                        tileSize: 256,
                        noWrap: true,
                    },
                    getTileUrl: function (coords) {
                        // Always use server zoom 4 tiles, Leaflet will scale them
                        return `${API_BASE}/tiles/${dim}/${BASE_SERVER_ZOOM}/${coords.x}/${coords.y}.png?t=${Date.now()}`;
                    },
                    getAttribution: function () {
                        return 'Minecraft Map';
                    },
                    // Ensure 404s don't look broken
                    errorTileUrl:
                        'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=',
                });

                tileLayer = new L.TileLayer.Minecraft().addTo(map);
            }

            function loadTile() {
                const dim = document.getElementById('tile-dim').value;
                const z = document.getElementById('preview-z').value;
                const x = document.getElementById('preview-x').value;
                const y = document.getElementById('preview-y').value;

                const url = `${API_BASE}/tiles/${dim}/${z}/${x}/${y}.png?t=${Date.now()}`;
                const img = document.getElementById('tile-preview');
                img.src = url;

                const displayUrl = `${API_BASE}/tiles/${dim}/${z}/${x}/${y}.png`;
                document.getElementById('tile-url').innerText = displayUrl;

                img.onerror = () => {
                    document.getElementById('tile-url').innerText = displayUrl + ' (Not Found)';
                };
            }

            // Event Listeners
            document.getElementById('tile-dim').addEventListener('change', () => {
                updateMapLayer();
                loadTile();
            });

            // Initial Load
            updateMapLayer();
            loadTile();
            gridOverlay = new CoordGridOverlay(map); // Create grid overlay
            updateZoomDisplay(); // Initial zoom display

            // ==========================================
            // Player Markers
            // ==========================================

            // Proxy through our server to avoid CORS issues with the external API
            const PLAYER_HEAD_API = `${API_BASE}/players`;
            const PLAYER_REFRESH_INTERVAL = 2000; // Refresh every 2 seconds

            let playerMarkers = new Map(); // Map of player name -> Leaflet marker
            let playersVisible = true;
            let currentPlayers = []; // Store current player data

            // Default fallback head SVG
            const DEFAULT_HEAD_SVG =
                'data:image/svg+xml,' +
                encodeURIComponent(
                    `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect fill="#8B4513" width="32" height="32"/><rect fill="#F5DEB3" x="8" y="8" width="16" height="16"/></svg>`
                );

            /**
             * Get the player head image URL using their PlayFab ID
             */
            function getPlayerHeadUrl(playfabId) {
                if (!playfabId) {
                    return DEFAULT_HEAD_SVG;
                }
                // Use our server proxy to fetch the head image
                return `${PLAYER_HEAD_API}/head/${playfabId}`;
            }

            /**
             * Create a player marker element
             */
            function createPlayerMarkerHtml(player) {
                const headUrl = getPlayerHeadUrl(player.playfabId);
                return `
        <div class="player-marker">
          <img class="player-head" src="${headUrl}" alt="${player.name}" onerror="this.src='data:image/svg+xml,${encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32"><rect fill="#8B4513" width="32" height="32"/><rect fill="#F5DEB3" x="8" y="8" width="16" height="16"/></svg>')}'">
          <span class="player-name">${player.name}</span>
        </div>
      `;
            }

            /**
             * Update player markers on the map
             */
            function updatePlayerMarkers(players) {
                const currentDimension = document.getElementById('tile-dim').value;

                // Filter players by current dimension
                const dimensionPlayers = players.filter(p => p.dimension === currentDimension);

                // Track which players we've seen in this update
                const seenPlayers = new Set();

                dimensionPlayers.forEach(player => {
                    seenPlayers.add(player.name);

                    // Convert Minecraft coords to Leaflet coords
                    const latLng = minecraftToLeaflet(player.x, player.z);

                    if (playerMarkers.has(player.name)) {
                        // Update existing marker position
                        const marker = playerMarkers.get(player.name);
                        marker.setLatLng(latLng);
                        // Update the popup content if it exists
                        if (marker.getPopup()) {
                            marker.setPopupContent(
                                `<b>${player.name}</b><br>X: ${Math.floor(player.x)}, Y: ${Math.floor(player.y)}, Z: ${Math.floor(player.z)}`
                            );
                        }
                    } else {
                        // Create new marker
                        const icon = L.divIcon({
                            html: createPlayerMarkerHtml(player),
                            className: '',
                            iconSize: [60, 60],
                            iconAnchor: [30, 30],
                        });

                        const marker = L.marker(latLng, { icon, interactive: true }).bindPopup(
                            `<b>${player.name}</b><br>X: ${Math.floor(player.x)}, Y: ${Math.floor(player.y)}, Z: ${Math.floor(player.z)}`
                        );

                        if (playersVisible) {
                            marker.addTo(map);
                        }

                        playerMarkers.set(player.name, marker);
                    }
                });

                // Remove markers for players no longer in this dimension or offline
                for (const [name, marker] of playerMarkers) {
                    if (!seenPlayers.has(name)) {
                        map.removeLayer(marker);
                        playerMarkers.delete(name);
                    }
                }
            }

            /**
             * Update the player list in the sidebar
             */
            function updatePlayerList(players) {
                const currentDimension = document.getElementById('tile-dim').value;
                const listEl = document.getElementById('player-list');
                const countEl = document.getElementById('player-count');

                const dimensionPlayers = players.filter(p => p.dimension === currentDimension);
                const totalPlayers = players.length;

                countEl.textContent = `${dimensionPlayers.length} in dimension (${totalPlayers} total)`;

                listEl.innerHTML = dimensionPlayers
                    .map(player => {
                        const headUrl = getPlayerHeadUrl(player.playfabId);
                        return `
          <div class="player-list-item" onclick="panToPlayer('${player.name}')">
            <img src="${headUrl}" alt="${player.name}" onerror="this.src='data:image/svg+xml,${encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"><rect fill="#8B4513" width="24" height="24"/><rect fill="#F5DEB3" x="6" y="6" width="12" height="12"/></svg>')}'">
            <div class="player-info">
              <div>${player.name}</div>
              <div class="player-coords">X: ${Math.floor(player.x)}, Z: ${Math.floor(player.z)}</div>
            </div>
          </div>
        `;
                    })
                    .join('');
            }

            /**
             * Pan the map to a specific player
             */
            function panToPlayer(name) {
                const player = currentPlayers.find(p => p.name === name);
                if (player) {
                    const latLng = minecraftToLeaflet(player.x, player.z);
                    map.setView(latLng, Math.max(map.getZoom(), 4)); // Zoom in a bit when panning to player
                }
            }

            /**
             * Fetch players from the API
             */
            async function fetchPlayers() {
                try {
                    const response = await fetch(`${API_BASE}/players`);
                    if (!response.ok) throw new Error('Failed to fetch players');

                    const data = await response.json();
                    if (data.success && data.data && data.data.players) {
                        currentPlayers = data.data.players;
                        updatePlayerMarkers(currentPlayers);
                        updatePlayerList(currentPlayers);
                    }
                } catch (error) {
                    console.error('Error fetching players:', error);
                }
            }

            /**
             * Toggle player visibility
             */
            function setPlayersVisible(visible) {
                playersVisible = visible;
                for (const marker of playerMarkers.values()) {
                    if (visible) {
                        marker.addTo(map);
                    } else {
                        map.removeLayer(marker);
                    }
                }
            }

            // Event listeners for player visibility
            document.getElementById('show-players').addEventListener('change', function () {
                setPlayersVisible(this.checked);
            });

            // Refresh markers when dimension changes
            document.getElementById('tile-dim').addEventListener('change', () => {
                // Clear all current markers and refetch
                for (const marker of playerMarkers.values()) {
                    map.removeLayer(marker);
                }
                playerMarkers.clear();
                updatePlayerMarkers(currentPlayers);
                updatePlayerList(currentPlayers);
            });

            // Initial fetch and start polling
            fetchPlayers();
            setInterval(fetchPlayers, PLAYER_REFRESH_INTERVAL);
        </script>
    </body>
</html>
