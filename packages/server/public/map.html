<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Map Viewer - Minecraft Map API</title>
        <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
        <style>
            * {
                box-sizing: border-box;
            }
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
                margin: 0;
                padding: 0;
                background: #1a1a2e;
                color: #eee;
                height: 100vh;
                display: flex;
                flex-direction: column;
            }
            header {
                background: #0f3460;
                padding: 10px 20px;
                display: flex;
                align-items: center;
                justify-content: space-between;
                border-bottom: 1px solid #1f4068;
            }
            h1 {
                margin: 0;
                font-size: 1.2rem;
                color: #6dd5ed;
            }
            .nav-btn {
                background: #16213e;
                color: #6dd5ed;
                text-decoration: none;
                padding: 8px 12px;
                border-radius: 4px;
                border: 1px solid #6dd5ed;
                font-size: 0.9rem;
            }
            .nav-btn:hover {
                background: #6dd5ed;
                color: #16213e;
            }

            main {
                flex: 1;
                display: flex;
                overflow: hidden;
            }

            .sidebar {
                width: 300px;
                background: #16213e;
                border-right: 1px solid #0f3460;
                padding: 15px;
                overflow-y: auto;
                display: flex;
                flex-direction: column;
                gap: 20px;
            }

            .map-container {
                flex: 1;
                position: relative;
            }

            #map {
                width: 100%;
                height: 100%;
                background: #000;
            }

            /* Disable image smoothing for crisp pixel-art tiles */
            #map img,
            .leaflet-tile,
            #tile-preview {
                image-rendering: pixelated;
                image-rendering: -moz-crisp-edges;
                image-rendering: crisp-edges;
            }

            /* Disable Leaflet's default tile fade animation to prevent flashing */
            .leaflet-tile-container {
                opacity: 1 !important;
            }
            .leaflet-tile {
                opacity: 1 !important;
                transition: none !important;
            }
            .leaflet-fade-anim .leaflet-tile {
                transition: none !important;
            }

            /* Coordinate display */
            .coord-display {
                position: absolute;
                bottom: 10px;
                left: 10px;
                background: rgba(15, 52, 96, 0.9);
                color: #6dd5ed;
                padding: 8px 12px;
                border-radius: 4px;
                font-family: 'Consolas', 'Monaco', monospace;
                font-size: 14px;
                z-index: 1000;
                border: 1px solid #1f4068;
                pointer-events: none;
            }
            .coord-display .label {
                color: #888;
                font-size: 11px;
            }

            /* Grid line styling */
            .coord-grid-canvas {
                position: absolute;
                top: 0;
                left: 0;
                pointer-events: none;
                z-index: 500;
            }

            /* Grid labels */
            .grid-label {
                position: absolute;
                background: rgba(15, 52, 96, 0.9);
                color: #6dd5ed;
                padding: 2px 6px;
                border-radius: 3px;
                font-family: 'Consolas', 'Monaco', monospace;
                font-size: 11px;
                white-space: nowrap;
                border: 1px solid #1f4068;
                pointer-events: none;
                z-index: 501;
            }

            /* Player markers */
            .player-marker {
                display: flex;
                flex-direction: column;
                align-items: center;
                pointer-events: auto;
            }
            .player-head {
                width: 32px;
                height: 32px;
                border: 2px solid #6dd5ed;
                border-radius: 4px;
                background: #16213e;
                image-rendering: pixelated;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
            }
            .player-name {
                margin-top: 4px;
                background: rgba(15, 52, 96, 0.9);
                color: #6dd5ed;
                padding: 2px 6px;
                border-radius: 3px;
                font-family: 'Consolas', 'Monaco', monospace;
                font-size: 11px;
                white-space: nowrap;
                border: 1px solid #1f4068;
            }

            /* Player stats popup styling */
            .player-popup {
                min-width: 320px;
                background: #1a1a1a;
                padding: 12px;
                border-radius: 6px;
            }
            /* Remove default Leaflet popup styling */
            .player-popup-container .leaflet-popup-content-wrapper {
                background: #1a1a1a;
                border: none;
                box-shadow: 0 3px 14px rgba(0, 0, 0, 0.6);
                border-radius: 6px;
            }
            .player-popup-container .leaflet-popup-content {
                margin: 0;
            }
            .player-popup-container .leaflet-popup-tip {
                background: #1a1a1a;
            }
            .player-popup-header {
                display: flex;
                align-items: center;
                gap: 8px;
                margin-bottom: 8px;
                padding-bottom: 8px;
                border-bottom: 1px solid #333;
            }
            .player-popup-head {
                width: 32px;
                height: 32px;
                border-radius: 4px;
                image-rendering: pixelated;
            }
            .player-popup-name {
                font-weight: bold;
                font-size: 14px;
                color: #6dd5ed;
            }
            .player-popup-coords {
                font-size: 11px;
                color: #888;
                font-family: 'Consolas', 'Monaco', monospace;
            }
            .player-stats-row {
                display: flex;
                align-items: center;
                gap: 4px;
                margin: 6px 0;
                min-height: 27px;
            }
            .player-stats-label {
                width: 60px;
                font-size: 12px;
                color: #aaa;
            }
            .player-stats-icons {
                display: flex;
                gap: 0px;
                flex-wrap: wrap;
                width: 270px;
            }
            .stat-icon {
                width: 27px;
                height: 27px;
                image-rendering: pixelated;
                background-image: url('/icons.png');
                background-size: 768px 768px; /* 256x256 original * 3 */
                background-repeat: no-repeat;
                display: inline-block;
            }
            /* Heart icons - row 0 (y=0 in original, scaled 3x) */
            /* Icons are 9x9 original = 27x27 scaled. Positions are multiplied by 3 */
            .stat-icon.heart-empty {
                background-position: -48px 0;
            } /* x=16*3=48, y=0 */
            .stat-icon.heart-full {
                background-position: -156px 0;
            } /* x=52*3=156 */
            .stat-icon.heart-half {
                background-position: -183px 0;
            } /* x=61*3=183 */
            /* Armor icons - row 1 (y=9 in original = 27 scaled) */
            .stat-icon.armor-empty {
                background-position: -48px -27px;
            } /* x=16*3, y=9*3 */
            .stat-icon.armor-full {
                background-position: -102px -27px;
            } /* x=34*3=102 */
            .stat-icon.armor-half {
                background-position: -75px -27px;
            } /* x=25*3=75 */
            /* Hunger icons - row 3 (y=27 in original = 81 scaled) */
            .stat-icon.hunger-empty {
                background-position: -48px -81px;
            } /* x=16*3, y=27*3 */
            .stat-icon.hunger-full {
                background-position: -156px -81px;
            } /* x=52*3=156 */
            .stat-icon.hunger-half {
                background-position: -183px -81px;
            } /* x=61*3=183 */

            .stat-icon-half {
                width: 14px;
                height: 27px;
                overflow: hidden;
            }
            .stat-icon-half .stat-icon {
                width: 27px;
            }
            .player-stats-unavailable {
                font-size: 11px;
                color: #666;
                font-style: italic;
                margin-top: 8px;
            }

            /* Player list in sidebar */
            .player-list {
                max-height: 200px;
                overflow-y: auto;
            }
            .player-list-item {
                display: flex;
                align-items: center;
                gap: 8px;
                padding: 6px;
                background: #0f3460;
                border-radius: 4px;
                margin-bottom: 4px;
                cursor: pointer;
                transition: background 0.2s;
            }
            .player-list-item:hover {
                background: #1f4068;
            }
            .player-list-item img {
                width: 24px;
                height: 24px;
                border-radius: 3px;
                image-rendering: pixelated;
            }
            .player-list-item .player-info {
                flex: 1;
                font-size: 0.85rem;
            }
            .player-list-item .player-coords {
                font-size: 0.7rem;
                color: #888;
            }
            .player-count {
                font-size: 0.8rem;
                color: #888;
                margin-bottom: 8px;
            }

            .control-group {
                margin-bottom: 15px;
            }
            label {
                display: block;
                margin-bottom: 5px;
                color: #ccc;
                font-size: 0.9rem;
            }
            input,
            select {
                width: 100%;
                background: #0f3460;
                border: 1px solid #1f4068;
                color: white;
                padding: 6px;
                border-radius: 4px;
            }
            button {
                background: #e94560;
                color: white;
                border: none;
                padding: 8px 16px;
                border-radius: 4px;
                cursor: pointer;
                width: 100%;
                margin-top: 5px;
            }
            button:hover {
                background: #ff6b81;
            }

            /* Tile Preview */
            .tile-preview-container {
                margin-top: 20px;
                border-top: 1px solid #0f3460;
                padding-top: 20px;
            }
            #tile-preview {
                width: 100%;
                aspect-ratio: 1;
                border: 1px solid #e94560;
                background-color: #000;
                background-image:
                    linear-gradient(45deg, #222 25%, transparent 25%),
                    linear-gradient(-45deg, #222 25%, transparent 25%),
                    linear-gradient(45deg, transparent 75%, #222 75%),
                    linear-gradient(-45deg, transparent 75%, #222 75%);
                background-size: 20px 20px;
                margin-bottom: 5px;
                display: block;
            }
            .tile-info {
                font-family: monospace;
                font-size: 0.8rem;
                color: #888;
                word-break: break-all;
            }
        </style>
    </head>
    <body>
        <header>
            <h1>üó∫Ô∏è Map Viewer</h1>
            <div style="display: flex; gap: 10px">
                <a href="api-tester.html" class="nav-btn">API Tester</a>
                <a href="index.html" class="nav-btn">Home</a>
            </div>
        </header>

        <main>
            <div class="sidebar">
                <div class="control-group">
                    <label>Dimension</label>
                    <select id="tile-dim">
                        <option value="overworld">Overworld</option>
                        <option value="nether">Nether</option>
                        <option value="the_end">The End</option>
                    </select>
                </div>

                <div class="control-group">
                    <button onclick="updateMapLayer()">Refresh Map Layer</button>
                </div>

                <div class="control-group">
                    <label style="display: flex; align-items: center; gap: 8px">
                        <input type="checkbox" id="show-grid" checked style="width: auto" /> Show Coordinate Grid
                    </label>
                </div>

                <div class="control-group">
                    <label style="display: flex; align-items: center; gap: 8px">
                        <input type="checkbox" id="show-players" checked style="width: auto" /> Show Players
                    </label>
                </div>

                <div class="control-group">
                    <label>Online Players</label>
                    <div class="player-count" id="player-count">0 players</div>
                    <div class="player-list" id="player-list"></div>
                </div>

                <div class="tile-preview-container">
                    <label>Single Tile Inspector</label>
                    <div style="display: flex; gap: 5px; margin-bottom: 5px">
                        <div style="flex: 1">
                            <label style="font-size: 0.8em">Zoom (0=High)</label
                            ><input type="number" id="preview-z" value="2" min="0" max="7" />
                        </div>
                        <div style="flex: 1">
                            <label style="font-size: 0.8em">X</label><input type="number" id="preview-x" value="0" />
                        </div>
                        <div style="flex: 1">
                            <label style="font-size: 0.8em">Y</label><input type="number" id="preview-y" value="0" />
                        </div>
                    </div>
                    <button onclick="loadTile()">Preview Tile</button>
                    <img id="tile-preview" alt="Tile Preview" />
                    <div class="tile-info" id="tile-url"></div>
                </div>

                <div style="margin-top: auto; font-size: 0.8rem; color: #666">
                    <p>Pan: Drag</p>
                    <p>Zoom: Scroll</p>
                </div>
            </div>

            <div class="map-container">
                <div id="map"></div>
                <div class="coord-display" id="coord-display">
                    <div class="label">Minecraft Coordinates</div>
                    <div id="coord-text">X: 0, Z: 0</div>
                    <div id="zoom-text" style="font-size: 11px; color: #888; margin-top: 4px">Zoom: 3</div>
                </div>
            </div>
        </main>

        <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
        <script>
            const API_BASE = '/api/v1';

            // Server zoom levels: 0 (16 blocks/tile, highest detail) to 7 (2048 blocks/tile)
            // Leaflet: higher zoom = more zoomed in (bigger tiles visually)
            const MAX_ZOOM = 7;

            // Blocks per tile at each server zoom level (must match server constants!)
            // z0: 16 blocks per tile (1 chunk)
            // z4: 256 blocks per tile (1 pixel = 1 block)
            // z6: 1024 blocks per tile
            // z7: 2048 blocks per tile
            const BLOCKS_PER_TILE = {
                0: 16,
                1: 32,
                2: 64,
                3: 128,
                4: 256,
                5: 512,
                6: 1024,
                7: 2048,
            };

            // Base server zoom level used for tiles
            const BASE_SERVER_ZOOM = 4;
            // Blocks per tile at base server zoom
            const BASE_BLOCKS_PER_TILE = BLOCKS_PER_TILE[BASE_SERVER_ZOOM];

            // Map Init
            const map = L.map('map', {
                crs: L.CRS.Simple,
                minZoom: 0,
                maxZoom: MAX_ZOOM,
                center: [0, 0],
                zoom: 3,
                zoomControl: true,
                zoomSnap: 1,
                zoomDelta: 1,
            });

            let tileLayer;

            /**
             * Convert Leaflet coordinates to Minecraft world coordinates
             *
             * In Leaflet CRS.Simple at native zoom 3:
             * - 1 tile = 256 pixels = 32 latlng units (since pixel = latlng * 2^zoom)
             * - 1 tile = 256 blocks (BASE_BLOCKS_PER_TILE at server zoom 4)
             * - Therefore: 32 latlng units = 256 blocks, so 1 latlng = 8 blocks
             *
             * This is zoom-independent - Minecraft coords should be the same at any zoom level.
             */
            function leafletToMinecraft(latlng) {
                // At native zoom 3: 32 latlng units = 256 blocks
                // So blocksPerLatlngUnit = 256 / 32 = 8
                const blocksPerLatlngUnit = BASE_BLOCKS_PER_TILE / 32;

                const mcX = Math.floor(latlng.lng * blocksPerLatlngUnit);
                const mcZ = Math.floor(-latlng.lat * blocksPerLatlngUnit);

                return { x: mcX, z: mcZ };
            }

            /**
             * Convert Minecraft coordinates to Leaflet coordinates
             * This is zoom-independent.
             */
            function minecraftToLeaflet(mcX, mcZ) {
                const blocksPerLatlngUnit = BASE_BLOCKS_PER_TILE / 32;

                const lat = -(mcZ / blocksPerLatlngUnit);
                const lng = mcX / blocksPerLatlngUnit;

                return L.latLng(lat, lng);
            }

            /**
             * Update coordinate display with mouse position
             */
            function updateCoordDisplay(e) {
                const coords = leafletToMinecraft(e.latlng);
                document.getElementById('coord-text').textContent = `X: ${coords.x}, Z: ${coords.z}`;
            }

            /**
             * Update zoom display
             */
            function updateZoomDisplay() {
                const leafletZoom = map.getZoom();
                const nativeLeafletZoom = 3;
                const scale = Math.pow(2, leafletZoom - nativeLeafletZoom);
                const blocksPerTile = Math.round(BASE_BLOCKS_PER_TILE / scale);
                document.getElementById('zoom-text').textContent =
                    `Zoom: ${leafletZoom} (${blocksPerTile} blocks/tile)`;
            }

            map.on('mousemove', updateCoordDisplay);
            map.on('zoomend', updateZoomDisplay);

            /**
             * Canvas-based coordinate grid overlay
             * Draws clean grid lines at regular Minecraft coordinate intervals
             */
            class CoordGridOverlay {
                constructor(map) {
                    this.map = map;
                    this.canvas = null;
                    this.ctx = null;
                    this.labelContainer = null;
                    this.visible = true;
                    this._onMove = this._onMove.bind(this);
                    this._init();
                }

                _init() {
                    // Create canvas for grid lines
                    this.canvas = document.createElement('canvas');
                    this.canvas.className = 'coord-grid-canvas';
                    this.map.getContainer().appendChild(this.canvas);
                    this.ctx = this.canvas.getContext('2d');

                    // Create container for labels
                    this.labelContainer = document.createElement('div');
                    this.labelContainer.style.cssText =
                        'position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:501;overflow:hidden;';
                    this.map.getContainer().appendChild(this.labelContainer);

                    // Bind events
                    this.map.on('move zoom resize zoomend moveend', this._onMove);

                    // Initial render
                    this._resize();
                    this._render();
                }

                _resize() {
                    const container = this.map.getContainer();
                    const rect = container.getBoundingClientRect();
                    this.canvas.width = rect.width;
                    this.canvas.height = rect.height;
                    this.canvas.style.width = rect.width + 'px';
                    this.canvas.style.height = rect.height + 'px';
                }

                _onMove() {
                    this._resize();
                    this._render();
                }

                /**
                 * Choose grid spacing based on zoom level
                 * We want roughly 3-6 grid lines visible on screen
                 */
                _getGridSpacing() {
                    const leafletZoom = this.map.getZoom();
                    const nativeLeafletZoom = 3;
                    const scale = Math.pow(2, leafletZoom - nativeLeafletZoom);
                    const blocksPerPixel = BASE_BLOCKS_PER_TILE / (256 * scale);

                    // Approximate pixels per 1000 blocks
                    const pixelsPer1000Blocks = 1000 / blocksPerPixel;

                    // Choose spacing so we get reasonable number of lines
                    // Prefer nice round numbers in Minecraft coords
                    if (pixelsPer1000Blocks > 800) return 256; // Very zoomed in
                    if (pixelsPer1000Blocks > 400) return 512;
                    if (pixelsPer1000Blocks > 200) return 1024;
                    if (pixelsPer1000Blocks > 100) return 2048;
                    if (pixelsPer1000Blocks > 50) return 4096;
                    if (pixelsPer1000Blocks > 25) return 8192;
                    return 16384; // Very zoomed out
                }

                _render() {
                    if (!this.visible) {
                        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                        this.labelContainer.innerHTML = '';
                        return;
                    }

                    const ctx = this.ctx;
                    const width = this.canvas.width;
                    const height = this.canvas.height;

                    ctx.clearRect(0, 0, width, height);
                    this.labelContainer.innerHTML = '';

                    const spacing = this._getGridSpacing();

                    // Get bounds in Minecraft coordinates
                    const bounds = this.map.getBounds();
                    const topLeft = leafletToMinecraft(bounds.getNorthWest());
                    const bottomRight = leafletToMinecraft(bounds.getSouthEast());

                    // Calculate first grid line positions (round to spacing)
                    const startX = Math.floor(topLeft.x / spacing) * spacing;
                    const endX = Math.ceil(bottomRight.x / spacing) * spacing;
                    const startZ = Math.floor(bottomRight.z / spacing) * spacing;
                    const endZ = Math.ceil(topLeft.z / spacing) * spacing;

                    // Draw settings
                    ctx.strokeStyle = 'rgba(109, 213, 237, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([]);

                    const labels = [];

                    // Draw vertical lines (constant X)
                    for (let mcX = startX; mcX <= endX; mcX += spacing) {
                        const topPoint = minecraftToLeaflet(mcX, topLeft.z);
                        const bottomPoint = minecraftToLeaflet(mcX, bottomRight.z);

                        const topScreen = this.map.latLngToContainerPoint(topPoint);
                        const bottomScreen = this.map.latLngToContainerPoint(bottomPoint);

                        ctx.beginPath();
                        ctx.moveTo(Math.round(topScreen.x) + 0.5, 0);
                        ctx.lineTo(Math.round(bottomScreen.x) + 0.5, height);
                        ctx.stroke();

                        // Add X label at top
                        if (topScreen.x > 30 && topScreen.x < width - 30) {
                            labels.push({ x: topScreen.x, y: 10, text: `X: ${mcX}`, type: 'x' });
                        }
                    }

                    // Draw horizontal lines (constant Z)
                    for (let mcZ = startZ; mcZ <= endZ; mcZ += spacing) {
                        const leftPoint = minecraftToLeaflet(topLeft.x, mcZ);
                        const rightPoint = minecraftToLeaflet(bottomRight.x, mcZ);

                        const leftScreen = this.map.latLngToContainerPoint(leftPoint);
                        const rightScreen = this.map.latLngToContainerPoint(rightPoint);

                        ctx.beginPath();
                        ctx.moveTo(0, Math.round(leftScreen.y) + 0.5);
                        ctx.lineTo(width, Math.round(rightScreen.y) + 0.5);
                        ctx.stroke();

                        // Add Z label at left
                        if (leftScreen.y > 20 && leftScreen.y < height - 20) {
                            labels.push({ x: 10, y: leftScreen.y, text: `Z: ${mcZ}`, type: 'z' });
                        }
                    }

                    // Render labels
                    labels.forEach(label => {
                        const el = document.createElement('div');
                        el.className = 'grid-label';
                        el.textContent = label.text;
                        el.style.left = label.x + 'px';
                        el.style.top = label.y + 'px';
                        if (label.type === 'x') {
                            el.style.transform = 'translateX(-50%)';
                        }
                        this.labelContainer.appendChild(el);
                    });
                }

                setVisible(visible) {
                    this.visible = visible;
                    this.canvas.style.display = visible ? 'block' : 'none';
                    this.labelContainer.style.display = visible ? 'block' : 'none';
                    if (visible) this._render();
                }

                remove() {
                    this.map.off('move zoom resize zoomend moveend', this._onMove);
                    this.canvas.remove();
                    this.labelContainer.remove();
                }
            }

            let gridOverlay = null;

            document.getElementById('show-grid').addEventListener('change', function () {
                if (gridOverlay) {
                    gridOverlay.setVisible(this.checked);
                }
            });

            function updateMapLayer() {
                if (tileLayer) {
                    map.removeLayer(tileLayer);
                }

                const dim = document.getElementById('tile-dim').value;

                // Custom TileLayer with refresh support that doesn't cause flicker
                // Based on: https://github.com/Leaflet/Leaflet/issues/6659
                L.TileLayer.Minecraft = L.TileLayer.extend({
                    options: {
                        minZoom: 0,
                        maxZoom: MAX_ZOOM,
                        minNativeZoom: 3,
                        maxNativeZoom: 3,
                        tileSize: 256,
                        noWrap: true,
                    },

                    initialize: function (options) {
                        L.TileLayer.prototype.initialize.call(this, '', options);
                        this._currentDim = dim;

                        // Store reference to original _tileOnLoad
                        const originalTileOnLoad = this._tileOnLoad;

                        // Override _tileOnLoad to skip animation for refreshed tiles
                        this._tileOnLoad = function (done, tile) {
                            if (tile.hasAttribute('data-dynamic-refresh')) {
                                // This is a refreshed tile - skip animation, just mark as loaded
                                tile.removeAttribute('data-dynamic-refresh');
                                L.DomUtil.addClass(tile, 'leaflet-tile-loaded');
                                done(null, tile);
                            } else {
                                // Normal tile load - use original behavior
                                originalTileOnLoad.call(this, done, tile);
                            }
                        };
                    },

                    getTileUrl: function (coords) {
                        return `${API_BASE}/tiles/${this._currentDim}/${BASE_SERVER_ZOOM}/${coords.x}/${coords.y}.png`;
                    },

                    getAttribution: function () {
                        return 'Minecraft Map';
                    },

                    // Refresh specific tiles without flicker
                    refresh: function (tileCoords) {
                        const layer = this;
                        const tilesToRefresh = new Set(tileCoords.map(t => `${t.x}:${t.z}`));

                        // Temporarily disable map fade animation
                        const wasFadeAnimated = map._fadeAnimated;
                        map._fadeAnimated = false;

                        // Loop through internal _tiles object
                        for (const key in this._tiles) {
                            const tile = this._tiles[key];
                            if (!tile || !tile.el) continue;

                            const coords = tile.coords;
                            const tileKey = `${coords.x}:${coords.y}`;

                            if (tilesToRefresh.has(tileKey)) {
                                const newUrl = this.getTileUrl(coords) + '?v=' + Date.now();

                                // Preload the new image
                                const preloadImg = new Image();
                                preloadImg.onload = (function (tileEl, url) {
                                    return function () {
                                        // Mark tile for dynamic refresh (skip animation)
                                        tileEl.setAttribute('data-dynamic-refresh', 'true');
                                        // Swap the src - this will trigger _tileOnLoad
                                        tileEl.src = url;
                                    };
                                })(tile.el, newUrl);

                                preloadImg.src = newUrl;
                            }
                        }

                        // Re-enable fade animation after a short delay
                        setTimeout(function () {
                            map._fadeAnimated = wasFadeAnimated;
                        }, 1000);
                    },

                    // Ensure 404s don't look broken
                    errorTileUrl:
                        'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=',
                });

                tileLayer = new L.TileLayer.Minecraft().addTo(map);
            }

            function loadTile() {
                const dim = document.getElementById('tile-dim').value;
                const z = document.getElementById('preview-z').value;
                const x = document.getElementById('preview-x').value;
                const y = document.getElementById('preview-y').value;

                const url = `${API_BASE}/tiles/${dim}/${z}/${x}/${y}.png?t=${Date.now()}`;
                const img = document.getElementById('tile-preview');
                img.src = url;

                const displayUrl = `${API_BASE}/tiles/${dim}/${z}/${x}/${y}.png`;
                document.getElementById('tile-url').innerText = displayUrl;

                img.onerror = () => {
                    document.getElementById('tile-url').innerText = displayUrl + ' (Not Found)';
                };
            }

            // Event Listeners
            document.getElementById('tile-dim').addEventListener('change', () => {
                updateMapLayer();
                loadTile();
            });

            // Initial Load
            updateMapLayer();
            loadTile();
            gridOverlay = new CoordGridOverlay(map); // Create grid overlay
            updateZoomDisplay(); // Initial zoom display
            loadTile();
            gridOverlay = new CoordGridOverlay(map); // Create grid overlay
            updateZoomDisplay(); // Initial zoom display

            // ==========================================
            // Player Markers
            // ==========================================

            // Proxy through our server to avoid CORS issues with the external API
            const PLAYER_HEAD_API = `${API_BASE}/players`;
            const PLAYER_REFRESH_INTERVAL = 2000; // Refresh every 2 seconds
            const PLAYER_LERP_DURATION = 1000; // Duration for smooth position transitions (ms)

            let playerMarkers = new Map(); // Map of player name -> { marker, currentPos, targetPos, startPos, lerpStartTime }
            let playersVisible = true;
            let currentPlayers = []; // Store current player data
            let playerAnimationFrame = null; // Animation frame ID for player lerping

            /**
             * Linear interpolation between two values
             */
            function lerp(start, end, t) {
                return start + (end - start) * t;
            }

            /**
             * Smooth easing function (ease-out cubic)
             */
            function easeOutCubic(t) {
                return 1 - Math.pow(1 - t, 3);
            }

            /**
             * Update all player marker positions with smooth lerping
             */
            function updatePlayerLerp(timestamp) {
                let anyAnimating = false;

                for (const [name, data] of playerMarkers) {
                    if (!data.targetPos || !data.startPos || !data.lerpStartTime) continue;

                    const elapsed = timestamp - data.lerpStartTime;
                    const progress = Math.min(elapsed / PLAYER_LERP_DURATION, 1);
                    const easedProgress = easeOutCubic(progress);

                    if (progress < 1) {
                        anyAnimating = true;
                        // Interpolate position
                        const lat = lerp(data.startPos.lat, data.targetPos.lat, easedProgress);
                        const lng = lerp(data.startPos.lng, data.targetPos.lng, easedProgress);
                        data.currentPos = { lat, lng };
                        data.marker.setLatLng([lat, lng]);
                    } else {
                        // Animation complete, snap to target
                        data.currentPos = { ...data.targetPos };
                        data.marker.setLatLng([data.targetPos.lat, data.targetPos.lng]);
                        data.startPos = null;
                        data.lerpStartTime = null;
                    }
                }

                if (anyAnimating) {
                    playerAnimationFrame = requestAnimationFrame(updatePlayerLerp);
                } else {
                    playerAnimationFrame = null;
                }
            }

            /**
             * Start the player lerp animation loop if not already running
             */
            function startPlayerLerpAnimation() {
                if (!playerAnimationFrame) {
                    playerAnimationFrame = requestAnimationFrame(updatePlayerLerp);
                }
            }

            // Default fallback head SVG
            const DEFAULT_HEAD_SVG =
                'data:image/svg+xml,' +
                encodeURIComponent(
                    `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect fill="#8B4513" width="32" height="32"/><rect fill="#F5DEB3" x="8" y="8" width="16" height="16"/></svg>`
                );

            // Icon class names for the spritesheet
            const ICON_CLASSES = {
                heart: { full: 'heart-full', half: 'heart-half', empty: 'heart-empty' },
                hunger: { full: 'hunger-full', half: 'hunger-half', empty: 'hunger-empty' },
                armor: { full: 'armor-full', half: 'armor-half', empty: 'armor-empty' },
            };

            /**
             * Generate stat icons HTML for a given value (0-20 scale)
             * @param {number} value - Current value (0-20)
             * @param {number} maxValue - Maximum value (typically 20)
             * @param {object} iconClasses - Object with full, half, empty class names
             * @returns {string} HTML string with icons
             */
            function generateStatIcons(value, maxValue, iconClasses) {
                const totalIcons = Math.ceil(maxValue / 2); // 10 icons for 20 points
                const fullIcons = Math.floor(value / 2);
                const hasHalf = value % 2 >= 1;
                const emptyIcons = totalIcons - fullIcons - (hasHalf ? 1 : 0);

                let html = '';
                for (let i = 0; i < fullIcons; i++) {
                    html += `<span class="stat-icon ${iconClasses.full}"></span>`;
                }
                if (hasHalf) {
                    html += `<span class="stat-icon ${iconClasses.half}"></span>`;
                }
                for (let i = 0; i < emptyIcons; i++) {
                    html += `<span class="stat-icon ${iconClasses.empty}"></span>`;
                }
                return html;
            }

            /**
             * Create the popup content for a player
             */
            function createPlayerPopupContent(player) {
                const headUrl = getPlayerHeadUrl(player.playfabId);
                const coords = `X: ${Math.floor(player.x)}, Y: ${Math.floor(player.y)}, Z: ${Math.floor(player.z)}`;

                let statsHtml = '';
                if (player.stats) {
                    const healthIcons = generateStatIcons(
                        player.stats.health,
                        player.stats.maxHealth || 20,
                        ICON_CLASSES.heart
                    );
                    const hungerIcons = generateStatIcons(player.stats.hunger, 20, ICON_CLASSES.hunger);
                    const armorIcons = generateStatIcons(player.stats.armor, 20, ICON_CLASSES.armor);

                    statsHtml = `
                        <div class="player-stats-row">
                            <span class="player-stats-label">Health:</span>
                            <div class="player-stats-icons">${healthIcons}</div>
                        </div>
                        <div class="player-stats-row">
                            <span class="player-stats-label">Hunger:</span>
                            <div class="player-stats-icons">${hungerIcons}</div>
                        </div>
                        <div class="player-stats-row">
                            <span class="player-stats-label">Armor:</span>
                            <div class="player-stats-icons">${armorIcons}</div>
                        </div>
                    `;
                } else {
                    statsHtml = '<div class="player-stats-unavailable">Stats not available</div>';
                }

                return `
                    <div class="player-popup">
                        <div class="player-popup-header">
                            <img class="player-popup-head" src="${headUrl}" alt="${player.name}" onerror="this.src='${DEFAULT_HEAD_SVG}'">
                            <div>
                                <div class="player-popup-name">${player.name}</div>
                                <div class="player-popup-coords">${coords}</div>
                            </div>
                        </div>
                        ${statsHtml}
                    </div>
                `;
            }

            /**
             * Get the player head image URL using their PlayFab ID
             */
            function getPlayerHeadUrl(playfabId) {
                if (!playfabId) {
                    return DEFAULT_HEAD_SVG;
                }
                // Use our server proxy to fetch the head image
                return `${PLAYER_HEAD_API}/head/${playfabId}`;
            }

            /**
             * Create a player marker element
             */
            function createPlayerMarkerHtml(player) {
                const headUrl = getPlayerHeadUrl(player.playfabId);
                return `
        <div class="player-marker">
          <img class="player-head" src="${headUrl}" alt="${player.name}" onerror="this.src='data:image/svg+xml,${encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32"><rect fill="#8B4513" width="32" height="32"/><rect fill="#F5DEB3" x="8" y="8" width="16" height="16"/></svg>')}'">
          <span class="player-name">${player.name}</span>
        </div>
      `;
            }

            /**
             * Update player markers on the map
             */
            function updatePlayerMarkers(players) {
                const currentDimension = document.getElementById('tile-dim').value;

                // Filter players by current dimension
                const dimensionPlayers = players.filter(p => p.dimension === currentDimension);

                // Track which players we've seen in this update
                const seenPlayers = new Set();

                dimensionPlayers.forEach(player => {
                    seenPlayers.add(player.name);

                    // Convert Minecraft coords to Leaflet coords
                    const latLng = minecraftToLeaflet(player.x, player.z);
                    const targetPos = { lat: latLng.lat, lng: latLng.lng };

                    if (playerMarkers.has(player.name)) {
                        // Update existing marker - set up lerp animation
                        const data = playerMarkers.get(player.name);

                        // Only start a new lerp if the target position has changed
                        if (
                            !data.targetPos ||
                            Math.abs(data.targetPos.lat - targetPos.lat) > 0.0001 ||
                            Math.abs(data.targetPos.lng - targetPos.lng) > 0.0001
                        ) {
                            // Start lerp from current position (or current target if mid-animation)
                            data.startPos = data.currentPos ? { ...data.currentPos } : targetPos;
                            data.targetPos = targetPos;
                            data.lerpStartTime = performance.now();

                            // Start the animation loop
                            startPlayerLerpAnimation();
                        }

                        // Update the popup content if it exists
                        if (data.marker.getPopup()) {
                            data.marker.setPopupContent(createPlayerPopupContent(player));
                        }

                        // Store updated player data for popup updates
                        data.player = player;
                    } else {
                        // Create new marker
                        const icon = L.divIcon({
                            html: createPlayerMarkerHtml(player),
                            className: '',
                            iconSize: [60, 60],
                            iconAnchor: [30, 30],
                        });

                        const marker = L.marker(latLng, { icon, interactive: true }).bindPopup(
                            createPlayerPopupContent(player),
                            { className: 'player-popup-container', maxWidth: 360 }
                        );

                        if (playersVisible) {
                            marker.addTo(map);
                        }

                        // Store marker data with position tracking for lerping
                        playerMarkers.set(player.name, {
                            marker,
                            player,
                            currentPos: targetPos,
                            targetPos: targetPos,
                            startPos: null,
                            lerpStartTime: null,
                        });
                    }
                });

                // Remove markers for players no longer in this dimension or offline
                for (const [name, data] of playerMarkers) {
                    if (!seenPlayers.has(name)) {
                        map.removeLayer(data.marker);
                        playerMarkers.delete(name);
                    }
                }
            }

            /**
             * Update the player list in the sidebar
             */
            function updatePlayerList(players) {
                const currentDimension = document.getElementById('tile-dim').value;
                const listEl = document.getElementById('player-list');
                const countEl = document.getElementById('player-count');

                const dimensionPlayers = players.filter(p => p.dimension === currentDimension);
                const totalPlayers = players.length;

                countEl.textContent = `${dimensionPlayers.length} in dimension (${totalPlayers} total)`;

                listEl.innerHTML = dimensionPlayers
                    .map(player => {
                        const headUrl = getPlayerHeadUrl(player.playfabId);
                        return `
          <div class="player-list-item" onclick="panToPlayer('${player.name}')">
            <img src="${headUrl}" alt="${player.name}" onerror="this.src='data:image/svg+xml,${encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"><rect fill="#8B4513" width="24" height="24"/><rect fill="#F5DEB3" x="6" y="6" width="12" height="12"/></svg>')}'">
            <div class="player-info">
              <div>${player.name}</div>
              <div class="player-coords">X: ${Math.floor(player.x)}, Z: ${Math.floor(player.z)}</div>
            </div>
          </div>
        `;
                    })
                    .join('');
            }

            /**
             * Pan the map to a specific player
             */
            function panToPlayer(name) {
                const player = currentPlayers.find(p => p.name === name);
                if (player) {
                    const latLng = minecraftToLeaflet(player.x, player.z);
                    map.setView(latLng, Math.max(map.getZoom(), 4)); // Zoom in a bit when panning to player
                }
            }

            /**
             * Fetch players from the API
             */
            async function fetchPlayers() {
                try {
                    const response = await fetch(`${API_BASE}/players`);
                    if (!response.ok) throw new Error('Failed to fetch players');

                    const data = await response.json();
                    if (data.success && data.data && data.data.players) {
                        currentPlayers = data.data.players;
                        updatePlayerMarkers(currentPlayers);
                        updatePlayerList(currentPlayers);
                    }
                } catch (error) {
                    console.error('Error fetching players:', error);
                }
            }

            /**
             * Toggle player visibility
             */
            function setPlayersVisible(visible) {
                playersVisible = visible;
                for (const data of playerMarkers.values()) {
                    if (visible) {
                        data.marker.addTo(map);
                    } else {
                        map.removeLayer(data.marker);
                    }
                }
            }

            // Event listeners for player visibility
            document.getElementById('show-players').addEventListener('change', function () {
                setPlayersVisible(this.checked);
            });

            // Refresh markers when dimension changes
            document.getElementById('tile-dim').addEventListener('change', () => {
                // Clear all current markers and refetch
                for (const data of playerMarkers.values()) {
                    map.removeLayer(data.marker);
                }
                playerMarkers.clear();
                updatePlayerMarkers(currentPlayers);
                updatePlayerList(currentPlayers);
            });

            // ==========================================
            // WebSocket for Real-time Updates
            // ==========================================

            let ws = null;
            let wsReconnectTimer = null;
            let wsConnected = false;
            const WS_RECONNECT_DELAY = 3000;

            /**
             * Create WebSocket URL based on current page location
             */
            function getWebSocketUrl() {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                return `${protocol}//${window.location.host}/ws`;
            }

            /**
             * Connect to WebSocket server
             */
            function connectWebSocket() {
                if (ws && (ws.readyState === WebSocket.CONNECTING || ws.readyState === WebSocket.OPEN)) {
                    return; // Already connected or connecting
                }

                const url = getWebSocketUrl();
                console.log('[WebSocket] Connecting to', url);

                try {
                    ws = new WebSocket(url);

                    ws.onopen = () => {
                        console.log('[WebSocket] Connected');
                        wsConnected = true;
                        updateConnectionStatus(true);

                        // Clear any reconnect timer
                        if (wsReconnectTimer) {
                            clearTimeout(wsReconnectTimer);
                            wsReconnectTimer = null;
                        }
                    };

                    ws.onclose = () => {
                        console.log('[WebSocket] Disconnected');
                        wsConnected = false;
                        updateConnectionStatus(false);

                        // Schedule reconnect
                        if (!wsReconnectTimer) {
                            wsReconnectTimer = setTimeout(() => {
                                wsReconnectTimer = null;
                                connectWebSocket();
                            }, WS_RECONNECT_DELAY);
                        }
                    };

                    ws.onerror = error => {
                        console.error('[WebSocket] Error:', error);
                    };

                    ws.onmessage = event => {
                        try {
                            const data = JSON.parse(event.data);
                            handleWebSocketEvent(data);
                        } catch (error) {
                            console.error('[WebSocket] Failed to parse message:', error);
                        }
                    };
                } catch (error) {
                    console.error('[WebSocket] Failed to create connection:', error);
                }
            }

            /**
             * Handle incoming WebSocket events
             */
            function handleWebSocketEvent(event) {
                const { type } = event;

                switch (type) {
                    case 'connection:established':
                        console.log('[WebSocket] Connection established:', event.message);
                        break;

                    case 'player:update':
                        // Update player positions
                        if (event.players && Array.isArray(event.players)) {
                            // Merge with existing players
                            for (const player of event.players) {
                                const index = currentPlayers.findIndex(p => p.name === player.name);
                                if (index >= 0) {
                                    currentPlayers[index] = player;
                                } else {
                                    currentPlayers.push(player);
                                }
                            }
                            updatePlayerMarkers(currentPlayers);
                            updatePlayerList(currentPlayers);
                        }
                        break;

                    case 'player:join':
                        // Add new player
                        if (event.player) {
                            const existingIndex = currentPlayers.findIndex(p => p.name === event.player.name);
                            if (existingIndex >= 0) {
                                currentPlayers[existingIndex] = event.player;
                            } else {
                                currentPlayers.push(event.player);
                            }
                            updatePlayerMarkers(currentPlayers);
                            updatePlayerList(currentPlayers);
                            console.log('[WebSocket] Player joined:', event.player.name);
                        }
                        break;

                    case 'player:leave':
                        // Remove player
                        if (event.playerName) {
                            currentPlayers = currentPlayers.filter(p => p.name !== event.playerName);
                            // Remove marker
                            const data = playerMarkers.get(event.playerName);
                            if (data) {
                                map.removeLayer(data.marker);
                                playerMarkers.delete(event.playerName);
                            }
                            updatePlayerList(currentPlayers);
                            console.log('[WebSocket] Player left:', event.playerName);
                        }
                        break;

                    case 'tile:update':
                        // Refresh affected tiles
                        if (event.tiles && Array.isArray(event.tiles)) {
                            handleTileUpdates(event.tiles);
                        }
                        break;

                    default:
                        console.log('[WebSocket] Unknown event type:', type);
                }
            }

            /**
             * Handle tile update events - refresh only the specific tiles that changed
             */
            function handleTileUpdates(tiles) {
                const currentDimension = document.getElementById('tile-dim').value;

                // Filter to tiles in current dimension and at our display zoom level
                const relevantTiles = tiles.filter(
                    tile => tile.dimension === currentDimension && tile.zoom === BASE_SERVER_ZOOM
                );

                if (relevantTiles.length === 0) {
                    return;
                }

                // Refresh only the specific tiles that were updated
                if (tileLayer && tileLayer.refresh) {
                    tileLayer.refresh(relevantTiles);
                }
            }

            /**
             * Update the connection status indicator
             */
            function updateConnectionStatus(connected) {
                let statusEl = document.getElementById('ws-status');
                if (!statusEl) {
                    // Create status indicator if it doesn't exist
                    statusEl = document.createElement('div');
                    statusEl.id = 'ws-status';
                    statusEl.style.cssText = `
                        position: absolute;
                        top: 10px;
                        right: 10px;
                        padding: 6px 12px;
                        border-radius: 4px;
                        font-size: 12px;
                        z-index: 1000;
                        pointer-events: none;
                    `;
                    document.querySelector('.map-container').appendChild(statusEl);
                }

                if (connected) {
                    statusEl.style.background = 'rgba(46, 204, 113, 0.9)';
                    statusEl.style.color = '#fff';
                    statusEl.textContent = '‚óè Live';
                } else {
                    statusEl.style.background = 'rgba(231, 76, 60, 0.9)';
                    statusEl.style.color = '#fff';
                    statusEl.textContent = '‚óã Reconnecting...';
                }
            }

            // Initial fetch (before WebSocket connects)
            fetchPlayers();

            // Connect to WebSocket
            connectWebSocket();

            // Fallback polling - only if WebSocket is not connected
            // Reduced frequency since WebSocket handles real-time updates
            setInterval(() => {
                if (!wsConnected) {
                    fetchPlayers();
                }
            }, PLAYER_REFRESH_INTERVAL * 2);
        </script>
    </body>
</html>
